# 图解HTTP

[TOC]



## 了解Web及网络基础

### 使用HTTP协议访问Web

Web使用HTTP（超文本传输协议）的协议作为规范，完成从客户端到服务器端等一系列运作流程，可以说Web是建立在HTTP协议上通信的。

### 网络基础TCP/IP

HTTP属于TCP/IP协议族内部的一个子集

#### TCP/IP协议族

计算机与网络设备、不同硬件与操作系统等等之间的通信需要遵循的规则称为协议，把互联网相关联的协议集合起来总称为TCP/IP

#### TCP/IP的分层管理

TCP/IP协议族按层次分别分为应用层、传输层、网络层、数据链路层

**应用层**

- 应用层决定了向用户提供应用服务时通信的活动；
- TCP/IP协议族内预存了各类通用的应用服务，比如FTP（File Transfer Protocol，文件传输协议）和DNS（Domain Name System，域名系统）服务就是其中两类。HTTP协议也处于该层；

**传输层**

- 传输层对上层应用层，提供处理网络连接中的两台计算机之间的数据传输；
- 在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）；

**网络层**

- 网络层用来处理网路上流动的数据包，数据包是网络传输的最小数据单位，该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方；
- 与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线；

**链路层**

用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（网卡）及光纤等物理可见部分。硬件上的范畴均在链路层的作用范围内；

#### TCP/IP通信传输流

利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信，发送端从应用层往下走，而接收端则从链路层往上走；

以HTTP举例：

1. 首先作为发送端的客户端在应用层（HTTP协议）发出一个想看某个Web页面的HTTP请求；
2. 接着为了传输方便，在传输层（TCP协议）把从应用层收到的数据（HTTP请求报文）进行分割，并在各个报文上标记序号及端口号后转发给网络层；
3. 在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层，这样一来，发往网络的通信请求就准备齐全了；
4. 接收端的服务器在链路层接收到数据，按序往上层发送，一直到达应用层，这样就算真正接收到由客户端发送过来的HTTP请求了；

### 与HTTP关系密切的协议：IP、TCP和DNS

#### 负责传输的IP协议

- IP网络协议属于网络层，它的作用是把各种数据包传送给对方，确保数据确实被传送到了对方那里，其中的两个重要条件是IP地址和MAC地址；
- IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址，两者可以进行配对；
- IP间的通信依赖MAC地址，在网络上，通信的双方很少在同一个局域网内，通常是经过多台计算机和网络设备中转。而在中转时会利用下一站中转设备的MAC地址来搜索下一个中转目标，这时会采用ARP协议（Address Resolution Protocol）。ARP协议是一种用以解析地址的协议，根据通信的IIP地址就可以反查出对应的MAC地址；

#### 确保可靠性的TCP协议

- TCP位于传输层，提供可靠的字节流服务——TCP协议为了更容易传送大数据会把数据分割成以报文段为单位的数据包，而且TCP协议能够确认数据最终是否送到到对方；
- 为了准确无误地将数据送达目标处。TCP协议采用了三次握手策略，握手过程中使用了TCP的标志——SYN（synchronize）和ACK（acknowledgement）：
- 发送端首先发送一个带有SYN标志的数据包给对方，接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后，发送端再回传一个带ACK标志的数据包，代表握手结束。若在握手过程中的某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包；

#### 负责域名解析的DNS

DNS服务是和HTTP协议一样位于应用层的协议，它提供域名到IP地址之间的解析服务；

### URI和URL

URL（Uniform Resource Locator，统一资源定位符），URI（Uniform Resource Identifier，统一资源标识符）

#### 统一资源标识符

URI就是某个协议方案表示的资源的定位标识符，协议方案是指访问资源所使用的协议类型名称

#### URI格式

如`http://user:pass@www.example.com:80/dir/index.htm?uid=1ch1`，即协议方案名 + 登录信息（认证）+ 服务器地址 + 服务器端口号 + 带层次的文件路径 + 查询字符串 + 片段标识符。

- 使用http:或https:等协议方案名获取访问资源时要指定协议类型；
- 登录信息，指定用户名和密码作为从服务器端获取资源时必要的登录信息，此项为可选项；
- 服务器地址：使用绝对URI必须指定待访问的服务器地址，可以是DNS可解析的域名，也可以是IPv4、IPv6地址；
- 服务器端口号：指定服务器连接的网络端口号，可选项；
- 带层次的文件路径：指定服务器上的文件路径来定位特指的资源；
- 查询字符串：针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数，可选；
- 片段标识符：通常可标记已获取资源中的子资源，可选；

**RFC（Request for Comments，征求修正意见书）**

通常应用程序会遵照由RFC确定的标准事先，可以说RFC是互联网的设计文档，要是不按照RFC标准执行，可能导致无法通信的状况；

## 简单的HTTP协议

### HTTP协议用于客户端和服务器端之间的通信

应用HTTP协议时，必然是一端担任客户端角色，另一端担任服务器端角色。仅从一条通信路线来说，服务器端和客户端的角色是确定的，用HTTP协议能够明确区分哪端是客户端，哪端是服务器端；

### 通过请求和响应的交换达成通信

HTTP协议规定，请求从客户端发出，最后服务器端响应请求并返回。

**请求报文**：是由请求方法（Method）、请求URI、协议版本、可选的请求首部字段和内容实体构成的；

**响应报文**：基本上由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成；

### HTTP是不保存状态（无状态）的协议

- HTTP协议自身不对请求和响应之间的通信状态进行保存，在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理；
- HTTP/1.1虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie技术；

### 请求URI定位资源

HTTP协议使用URI定位互联网上的资源

### 告知服务器意图的HTTP方法

- GET：获取资源。如果请求的资源是文本，则保持原样返回，如果是像CGI那样的程序，则返回经过执行后的输出结果；
- POST：传输实体主体。
- PUT：传输文件。鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。若配合Web应用程序的验证机制，或架构设计采用REST标准的同类Web网站，就可能会开放使用PUT方法；
- HEAD：获得报文首部。和GET方法一样，只是不返回报文主体部分，用于确定URI的有效性及资源更新的日期时间等；
- DELETE：删除文件。与PUT一样不带验证机制，当配合Web应用程序的验证机制或遵守REST标准时可能会开放使用；
- OPTIONS：询问支持的方法；
- TRACE：追踪路径。让Web服务器端将之前的请求通信环回给客户端的方法；但是TRACE方法本来就不怎么常用，再加上它容易引发XST（跨站追踪）攻击，通常就更不会用到了；
- CONNECT：要求用隧道协议连接代理。要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输；

### 使用方法下达命令

方法的作用在于，可以指定请求的资源按期望产生某种行为。

### 持久连接节省通信量

HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接；

#### 持久连接

- 为解决上述TCP连接问题，HTTP/1.1和一部分HTTP/1.0想出了持久连接（HTTP Persistent Connections，也被称为HTTP keep-alive或HTTP connection reuse）的方法，其特点是只要任意一端没有明确提出断开连接，则保持TCP连接状态；
- 持久连接旨在建立1次TCP连接后进行多次请求和响应的交互，其好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早地结束，这样Web页面地显示速度也就相应提高了；
- 在HTTP/1.1中，所有地连接默认都是持久连接，但在HTTP/1.0内并未标准化。毫无疑问，除了服务器端，客户端也需要支持持久连接；

#### 管线化

持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求，管线化技术出现后，不用等待响应亦可直接发送下一个请求；

### 使用Cookeie的状态管理

Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去；

服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息；

## HTTP报文内的HTTP信息

### HTTP报文

用于HTTP协议交互的信息被称为HTTP报文，请求端的报文叫作请求报文，响应端的报文叫作响应报文。HTTP报文大致可分为报文首部和报文主体，报文主体并不一定要有；

### 请求报文及响应报文的结构

请求报文和响应报文的**首部内容**由以下数据组成；

- **请求行**：包含用于请求的方法，请求URI和HTTP版本；
- **状态行**：包含表明响应结果的状态码，原因短语和HTTP版本；
- **首部字段**：包含表示请求和响应的各种条件和属性的各类首部，一般有4种首部：通用首部、请求首部、响应首部和实体首部；
- **其他**：可能包含HTTP的RFC里未定义的首部（Cookie等）

### 编码提升传输速率

HTTP在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求。但是编码的操作需要计算机来完成，因此会消耗更多的CPU等资源。

#### 报文主体和实体主体的差异

- 报文（message）：是HTTP通信中的基本单位，由8位字节流组成，通过HTTP通信传输；
- 实体（entity）：作用请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成；

通常，报文主体等于实体主体，只有当传输中进行编码操作时，实体的主体的内容发生变化，才导致它和报文主体产生差异。

#### 压缩传输的内容编码

内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩，内容编码后的实体由客户端接收并负责解码。

#### 分割发送的分块传输编码

- 在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）；
- 使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体；

### 发送多种数据的多部分对象集合

HTTP协议采纳了多部分对象集合的方法，可容纳多份不同类型的数据，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件上传时使用。多部分对象集合包含的对象如下：

- multipart/form-data：在web表单文件上传时使用；
- multipart/byteranges：状态码206（Partial Content）响应报文包含了多个范围的内容时使用；

在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-type；

多部分对象集合的每个部分类型中，都可以含有首部字段，另外可以在某个部分中嵌套使用多部分对象集合；

### 获取部分内容的范围请求

- 指定范围发送的请求叫作范围请求（如下载文件时从上次下载中断处恢复下载）；
- 执行范围请求时，会用到首部字段Range来指定资源的byte范围，如Range: bytes=5001-10000；
- 针对范围请求，响应会返回状态码为206 Partial Content的响应报文。另外，对于多重范围的范围请求，响应会在首部字段Content-type表明multipart/byteranges后返回响应报文；
- 如果服务器端无法响应范围请求，会返回状态码200 OK和完整的实体内容；

### 内容协商返回最合适的内容

- 同一个Web网站可能存在着多份相同内容的页面，比如英语版和中文版的Web页面，当浏览器默认语言为英语或中文，访问相同URI的Web页面时，则会显示对应的英语版或中文版的Web页面，这样的机制称为内容协商（Content Negotiation）；
- 内容协商机制是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。包含在请求报文中的某些首部字段就算判断基准：Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language；

内容协商技术有以下3种类型：

- 服务器驱动协商（Server-driven Negotiation）：以请求的首部字段为参考，在服务器端自动处理，但是对用户来说，以浏览器发送的信息作为判断的依据，并不一定能筛选出最优内容；
- 客户端驱动协商（Agent-driven Negotiation）：由客户端进行内容协商的方式。用户从浏览器显示的可选项列表种手动选择，还可以利用JavaScript脚本在Web页面上自动进行上述选择；
- 透明协商（Transparent Negotiation）：服务器端和客户端各自进行内容协商的一种方法；

## 返回结果的HTTP状态码

### 状态码告知从服务器端返回的请求结果

状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误；

**状态码的类别**

| 状态码 | 类型                             | 原因短语                   |
| ------ | -------------------------------- | -------------------------- |
| 1XX    | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX    | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX    | Server Error（服务器错误状态码） | 服务器处理请求出错         |

### 2XX成功

| 状态码 | 短语            | 说明                                                         |
| ------ | --------------- | ------------------------------------------------------------ |
| 200    | OK              | 请求正常被处理                                               |
| 204    | No Content      | 请求已成功处理，但是返回的响应报文中不含实体的主体部分       |
| 206    | Partial Content | 客户端进行了范围请求，响应报文中包含由Content-Range指定范围的实体内容 |

### 3XX重定向

浏览器需要执行某些特殊的处理以正确处理请求

| 状态码 | 短语              | 说明                                                         |
| ------ | ----------------- | ------------------------------------------------------------ |
| 301    | Moved Permanently | 永久性重定向。请求的资源已被分配了新的URI，以后应使用资源现在所指的URI |
| 302    | Found             | 临时性重定向。请求的资源已被分配了新的URI，本次应使用新的URI |
| 303    | See Other         | 303状态码和302有着相同的功能，但是303状态码明确表示客户端应当采用GET方法获取资源 |
| 304    | Not Modified      | 客户端发送附带条件的请求时，服务器允许请求访问资源，但未满足条件的请求 |
| 307    | Temporary Redirct | 临时重定向，与302有着相同的含义                              |

### 4XX客户端错误

表明客户端是发生错误的原因所在

| 状态码 | 短语         | 说明                                                         |
| ------ | ------------ | ------------------------------------------------------------ |
| 400    | Bad Request  | 请求报文中存在语法错误                                       |
| 401    | Unauthorized | 该状态码表示发送的请求需要有通过HTTP认证的认证信息，若之前已进行过1次请求，则表示用户认证失败 |
| 403    | Forbidden    | 对请求资源的访问被服务器拒绝了                               |
| 404    | Not Found    | 服务器上无法找到请求的资源                                   |

### 5XX服务器错误

表示服务器本身发生错误

| 状态码 | 短语                  | 说明                                                         |
| ------ | --------------------- | ------------------------------------------------------------ |
| 500    | Internal Server Error | 服务器端在执行请求时发生了错误，也有可能是Web应用存在的bug或某些临时的故障 |
| 503    | Service Unavailable   | 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求     |

## 与HTTP协作的Web服务器

一台Web服务器可搭建多个独立域名的Web网站，也可以作为通信路径上的中转服务器提升传输效率

### 用单台虚拟主机实现多个域名

- HTTP/1.1规范允许一台HTTP服务器搭建多个Web站点。比如。提供Web托管服务的供应商，可以用一台服务器为多位客户服务，也可以以每位客户持有的域名运行各自不同的网站，这是因为利用了虚拟主机的功能；
- 在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI；

### 通信数据转发程序：代理、网关、隧道

HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道，它们可以配合服务器工作。

- **代理**：代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端；
- **网关**：网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关；
- **隧道**：隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序；

#### 代理

- 代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI，会直接发送给前方持有资源的目标服务器。持有资源实体的服务器被称为源服务器，从源服务器返回的响应经过代理服务器后再传给客户端；
- 使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的等；

**缓存代理**

- 代理转发响应时，缓存代理会预先将资源的副本保存在代理服务器上；
- 当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取，而是将之前的资源作为响应返回；

**透明代理**：转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理，反之对报文内容进行加工的代理被称为非透明代理；

#### 网关

- 利用网关可以由HTTP请求转化为其他协议通信；
- 网关的工作机制和代理十分相似，而网关能使通信线路上的服务器提供非HTTP协议服务；
- 利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全；

#### 隧道

- 隧道可按照要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信，隧道的目的是确保客户端能与服务器进行安全通信；
- 隧道本身不会去解析HTTP请求，也就是说，请求保持原样中转给之后的服务器，隧道会在通信双方断开连接时结束；

### 保存资源的缓存

- 缓存是指代理服务器或客户端本地磁盘内保存的资源副本，利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间；
- 缓存服务器是代理服务器的一种，并归类在缓存代理类型中；

#### 缓存的有效期限

即时存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性，若判断缓存失效，缓存服务器将会再次从源服务器上获取新资源；

#### 客户端的缓存

缓存不仅可以存在缓存服务器内，还可以存在客户端浏览器中，把客户端缓存称为临时网络文件。当判断缓存过期后，会向源服务器确认资源的有效性，若判断浏览器缓存失效，浏览器会再次请求新资源；

## HTTP首部

HTTP协议的请求和响应报文中必定包含HTTP首部

### HTTP报文首部

HTTP请求报文首部由方法、URI、HTTP版本、HTTP首部字段等部分组成；

HTTP响应报文首部由HTTP版本、状态码（数字和原因短语）、HTTP首部字段3部分构成；

### HTTP首部字段（HTTP Headers）

- HTTP首部字段是构成HTTP报文的要素之一，使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容；
- HTTP首部字段由字段名和字段值构成，中间用冒号分隔，字段值可以有多个值；

HTTP首部字段根据实际用途被分为以下4种类型：

- 通用首部字段（General Header Fields）：请求报文和响应报文两方都会使用的首部；
- 请求首部字段（Request Header Fields）：请求报文使用，补充冷清秋的附加内容、客户端信息、响应内容优先级等信息；
- 响应首部字段（Response Header Fields）：响应报文使用，补充了响应的附加内容，也会要求客户端附加额外的内容信息；
- 实体首部字段（Entity Header Fields）：请求和响应报文实体部分使用的首部，补充了与实体有关的信息；

### HTTP/1.1通用首部字段

#### Cache-Control

通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制；

**缓存请求指令**

| 指令           | 参数 | 说明                                                         |
| -------------- | ---- | ------------------------------------------------------------ |
| no-cache       | 无   | 客户端将不会接收缓存过的响应                                 |
| no-store       | 无   | 不缓存请求或响应的任何内容                                   |
| max-age = [秒] | 必须 | 如果缓存资源的缓存时间小于此值，那么客户端就接收缓存的资源，否则将请求转发给源服务器 |

**缓存响应指令**

| 指令          | 参数   | 说明                                                         |
| ------------- | ------ | ------------------------------------------------------------ |
| public        | 无     | 可向任意方提供响应的缓存                                     |
| private       | 可省略 | 仅向特定用户返回响应                                         |
| no-cache      | 可省略 | 缓存服务器不能对资源进行缓存                                 |
| s-maxage=[秒] | 必须   | 公共缓存服务器响应的最大Age值                                |
| max-age=[秒]  | 必须   | 缓存服务器将不对资源的有效性再作确认，max-age代表资源保存为缓存的最长时间 |

#### Connection

**控制不再转发给代理的首部字段**

格式：Connection: 不再转发的首部字段名

**管理持久连接**

- Connection: close	HTTP/1.1版本的默认连接都是持久连接，为此客户端会在持久连接上连续发送请求，当服务器想明确断开连接时，则指定Connection首部字段的值为close；
- Connection: Keep-Alive	如果想再HTTP/1.1之前的HTTP协议上维持持久连接，则需要指定Connection的值为Keep-Alive

#### Date

表明持久HTTP报文的日期和时间；

#### Trailer

首部字段Trailer会实现说明在报文主体后记录了哪些首部字段，可应用在HTTP/1.1版本分块传输编码时；

#### Transfer-Encoding

规定了传输报文主体时采用的编码方式

#### Upgrade

用于检测HTTP协议及其他协议是否可使用更高的版本进行通信，其参数值可以用户指定一个完全不同的通信协议；使用时需额外指定Connection: Upgrade

#### Via

使用Via是为了追踪客户端与服务器之间的请求和响应报文的传输路径，还可避免请求回环的发生，所以必须在经过代理时附加该首部字段的内容；

#### Warning

告知用户一些与缓存相关的问题的警告

### 请求首部字段

#### Accept

通知给服务器用户代理能够处理的媒体类型及媒体类型的优先级；

使用q=来额外表示权重值（范围是0-1）；

#### Accept-Charset

通知给服务器用户代理支持的字符集及字符集的相对优先顺序；

#### Accept-Encoding

告知服务器用户代理支持的内容编码及内容编码的优先级顺序；

#### Accept-Language

告知服务器用户代理能够处理的自然语言集，以及自然语言集的相对优先级；

#### Authorization

用来告知服务器，用户代理的认证信息（证书值），通常，想要通过服务器认证的用户会在接收到返回的401状态码响应后，把首部字段Authorization加入请求中；

#### From

用来告诉服务器使用用户代理的用户的电子邮件地址

#### Host

告知服务器，请求的资源所处的互联网主机名和端口号，Host首部字段在HTTP/1.1规范内是唯一一个必须被包含在请求内的首部字段

#### Proxy-Authorization

接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization的请求，以告知服务器认证所需要的信息，认证行为发生在客户端与代理之间

#### Range

告知服务器需获取的资源的指定范围

#### User-Agent

将创建请求的浏览器和用户代理名称等信息传达给服务器，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称；

### 响应首部字段

#### Accept-Ranges

告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源，可处理时指定其为bytes，反之指定其为none；

#### Age

告知客户端，源服务器在多久前创建了响应，字段值单位为秒；

#### Location

使用首部字段Location可以将响应接收方引导至与请求URI位置不同的资源，配合3XX：Redirection的响应，提供重定向的URI；

#### Proxy-Authenticate

会把由代理服务器所要求的认证信息发送给客户端；

#### Retry-After

告知客户端应该在多久之后再次发送请求，主要配合503 Service Unavailable或3xx Redirect响应一起使用；

#### Server

告知客户端当前服务器上按照的HTTP服务器应用程序的信息；

#### Vary

当代理服务器接收到带有Vary首部字段指定获取资源的请求时，如果使用的Accept-Language字段的值相同，那么直接从缓存返回响应，反之从源服务器端获取资源后才能作为响应返回；

#### WWW-Authenticate

告知客户端适用于访问请求URI所指定资源的认证方案和带参数提示的质询；状态码401 Unauthorized响应中，肯定带有首部字段WWW-Authenticate；

### 实体首部字段

#### Allow

服务器通知客户端能够支持Request-URI指定资源的所有HTTP方法，当服务器接收到不支持的HTTP方法时，会以状态码405 Method Not Allowed作为响应返回，与此同时，还会把能支持的HTTP方法写入首部字段Allow后返回；

#### Content-Encoding

告知客户端服务器对实体的主体部分选用的内容编码方式，内容编码是指在不丢失实体信息的前途下进行的压缩；

#### Content-Language

告知客户端，实体主体使用的自然语言；

#### Content-Length

首部字段Content-Length表明了实体主体部分的字节为单位的大小；

#### Content-Location

给出与报文主体部分相对应的URI；

#### Content-MD5

用于检查报文主体在传输过程种是否保持完整，以及确认传输到达；

#### Content-Range

告知客户端作为响应返回的实体的哪个部分符合范围请求；

#### Content-Type

说明了实体主体内对象的媒体类型，和首部字段Accept一样，字段值用type/subtype形式赋值

#### Expires

Expires会将资源失效的日期告知客户端，缓存服务器在接收到含有首部字段Expires的响应后，会以缓存来应答请求，在Expires字段值指定的时间之前，响应的副本会一直被保存；

#### Last-Modified

指明资源最终修改的时间，一般来说，这个值就是Request-URI指定资源被修改的时间；

### 为Cookie服务的首部字段

- Cookie的工作机制是用户识别及状态管理，Web网站为了管理用户的状态会通过Web浏览器，把一些数据临时写入用户的计算机内，接着当用户访问该Web网站时，可通过通信方式取回之前发放的Cookie；
- 调用Cookie时，由于可校验Cookie的有效期，以及发送方的域、路径、协议等信息，所以正规发布的Cookie内的数据不会因来自其他Web站点和攻击者的攻击而泄漏；

#### Set-Cookie

当服务器准备开始管理客户端的状态时，会事先告知各种信息；

| 属性         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| NAME=VALUE   | 赋予Cookie的名称和其值                                       |
| expires=DATE | Cookie的有效期（默认为浏览器关闭前为止），服务器可通过覆盖已过期的Cookie来完成对Cookie的删除 |
| path=PATH    | 将服务器上的文件目录作为Cookie的适用对象，可用于限制指定Cookie的发送范围的文件目录（但是可以被避开） |
| domain=域名  | 作为Cookie适用对象的域名，默认为创建Cookie的服务器的域名     |
| Secure       | 仅在HTTPS安全通信时才会发送Cookie                            |
| HttpOnly     | 加以限制，使Cookie不能被JS脚本访问                           |

#### Cookie

首部字段Cookie会告知服务器，当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的Cookie；

### 其他首部字段

HTTP首部字段是可以自行扩展的，所以在Web服务器和浏览器的应用上，会出现各种非标准的首部字段；

#### X-Frame-Options

属于HTTP响应首部，用控制网站内容在其他Web网站的Frame标签内的显示问题，主要目的是防止点击劫持攻击。可设置两个指定字段值：

- DENY：拒绝；
- SAMEORIGIN：仅同源域名下的页面；

#### X-XSS-Protection

属于HTTP响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器XSS防护机制的开关，首部字段X-XSS-Protection可指定的字段值如下：

- 0：将XSS过滤设置为无效状态；
- 1：将XSS过滤设置为有效状态；

#### DNT

DNT属于HTTP请求首部，其中DNT是Do Not Track的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法，可指定字段值：

- 0：同意被追踪；
- 1：拒绝被追踪；

#### P3P

属于HTTP响应首部，通过利用P3P（The Platform for Privacy Preferences）技术，可以让Web网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的；

## 确保Web安全的HTTPS

### HTTP的缺点

- 通信适用铭明文（不加密），内容可能会被窃听；
- 不验证通信方的身份，因此有可能遭遇伪装；
- 无法验证报文的完整性，所以有可能已遭篡改；

#### 通信使用明文可能会被窃听

HTTP本身不具备加密的功能，按TCP/IP协议族的工作机制，通信内容在所有通信线路上都有可能遭到窥视；

防止窃听的对策中最普及的就是加密技术，加密的对象可以有：

**通信的加密**：HTTP协议没有加密机制，但可以通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）组合使用，从而加密HTTP的通信内容。用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了，与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）或HTTP over SSL；

**内容的加密**：对HTTP报文里所含的内容进行加密处理，客户端对HTTP请求报文进行加密处理，服务器使用同种加解密机制解密。内容仍有被篡改的风险；

#### 不验证通信方的身份就可能遭遇伪装

HTTP协议中的请求和响应不会对通信方进行确认，存在“服务器是否就是发送请求中URI真正指定的主机”，“返回的响应是否真的返回到实际提出请求的客户端”等问题；

**任何人都可以发起请求**

在HTTP协议通信时，不存在确认通信方的处理步骤，服务器只要接收到请求，都会返回一个响应；

**查明对手的证书**

SSL不仅提供加密处理，还使用了一种被称为证书的手段，可用于确定通信方。证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。

#### 无法证明报文完整性，可能已遭篡改

**接收到的内容可能有误**

- HTTP协议无法证明通信的报文完整性，因此在请求或响应送出之后直到对方接收之前的这段时间内，即时请求或响应的内容遭到篡改，也没有办法获悉；
- 请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack，MITM）；

**如何防止篡改**

- 虽然有使用HTTP协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是MD5和SHA-1等散列值校验的方法，以及用来确认文件的数字签名方法；
- 为了有效防止这些弊端，有必要使用HTTPS，SSL提供认证和加密处理及摘要功能，仅靠HTTP确保完整性是非常困难的，因此通过和其他协议组合使用来实现这个目标；

### HTTP + 加密 + 认证 + 完整性保护 = HTTPS

HTTP加上加密处理和认证以及完整性保护后即是HTTPS

#### HTTPS是身披SSL外壳的HTTP

- HTTPS并非是应用层的一种新协议，只是HTTP通信接口部分用SSL和TLS协议代替而已，通常HTTP直接和TCP通信，当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了；
- SSL是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的SMTP、Telnet等协议均可配合SSL协议使用，可以说SSL是当今世界上应用最广泛的网络安全技术；

#### 相互交互密钥的公开密钥加密技术

SSL采用公开密钥加密（Public-key cryptography）的加密处理方式；

**共享密钥加密的困境**

- 加密和解密同用一个密钥的加密方式称为共享密钥加密（Common key crypto system），也被称为对称密钥加密；
- 以共享密钥方式加密时必须将密钥也发给对象，在互联网上转发密钥时，如果通信被监听，那么密钥就可能会落入攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥；

**使用两把密钥的公开密钥加密**

公开密钥加密使用一对非对称的密钥，一把叫做私有密钥，另一把叫作公开密钥。使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。使用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走；（公钥加密，私钥解密）

**HTTPS采用混合加密机制**

HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制，在交换密钥环节使用公开密钥加密方式，之后<u>建立通信交换报文阶段则使用共享密钥加密方式</u>；

#### 证明公开密钥正确性的证书

公开密钥加密方式无法证明公开密钥本身是货真价实的公开密钥，为解决此问题，需要使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书；

**数字证书认证机构的业务流程**：服务器运营人员向数字证书机构申请公开密钥，CA在判明申请者身份后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起；

- 服务器会将这份由CA颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。
- 接收到证书的客户端可使用CA认证的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端可明确两件事：1.认证服务器的公开密钥是真实有效的数字证书认证机构；2.服务器的公开密钥是值得信赖的。
- 此处认证机关的公开密钥必须安全地转交给客户端，使用通信方式时，如何安全转交是一件很困难的事，因此多数浏览器开发商发布版本时就会实现在内部植入常用认证机关的公开密钥；

**图解：**

1. 服务器把自己的公开密钥（服务器公钥）登录至CA；
2. CA用自己的私有密钥（CA私钥）向服务器的公开密码部署数字签名并颁发公钥证书（给服务器），CA的公开密钥（CA公钥）已事先植入到浏览器里了；
3. 服务器把CA颁布的公钥证书（里面包含了服务器公钥和CA数字签名）发送给客户端；
4. 客户端拿到服务器的公钥证书后，使用CA公钥向CA验证公钥证书上的数字签名，以确认服务器公钥的真实性；
5. 客户端使用服务器公钥对报文加密后发送；
6. 服务器用服务器私钥对报文解密；

**可证明组织真实性的EV SSL证书**

证书的一个作用是用来证明作为通信一方的服务器是否规范，另一个作用是可确认对方服务器背后运行的企业是否真实存在拥有该特性的证书就是EV SSL证书（Extended Validation SSL Certificate）；

**用以确认客户端的客户端证书**

- HTTPS中还可以使用客户端证书。以客户端证书进行客户端认证，证明服务器正在通信的对方始终是预料之内的客户端；
- 想获取证书时，用户得自行安装客户端证书；
- 现状是，安全性极高得认证机构可颁发客户端证书，但仅用于特殊用途得业务，比如那些可支撑客户端证书支出费用得业务；
- 客户端证书存在的另一个问题是，它只能用来证书客户端实际存在，不能用来证明用户本人的真实有效性，所有只要获得了安装有客户端证书的计算机的使用权限，也就意味着同时拥有了客户端证书的使用权限；

**由自认证机构颁发的证书称为自签名证书**

如果使用OpenSSL这套开源程序，每个人都可以构造一套属于自己的认证机构，从而给自己颁发服务器证书。浏览器访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告信息；

#### HTTPS的安全通信机制

1. 客户端通过发送Client Hello报文开始SSL通信，报文中包含客户端支持的SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）；
2. 服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到客户端加密组件内筛选出来的；
3. 之后服务器发送Certificate报文，报文中包含公开密钥证书；
4. 最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束；
5. SSL第一次握手结束之后，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串。该报文已用步骤3中的公开密钥进行加密；
6. 接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密；
7. 客户端发送Finished报文，该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准；
8. 服务器同样发送Change Cipher Spec报文；
9. 服务器同样发送Finished报文；
10. 服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成，当然通信会受到SSL的保护，从此开始进行应用层协议的通信，即发送HTTP请求；
11. 应用层协议通信，即发送HTTP响应；
12. 最后由客户端断开连接。断开连接时，发送close_notify报文。之后再发送TCP FIN报文来关闭与TCP的通信；

应用层在发送数据时会附加一种叫作MAC（Message Authentication Code）的报文摘要，MAC能够查知报文是否遭到篡改，从而保护报文的完整性；

**SSL和TLS**：HTTPS使用SSL和TLS这两个协议

**SSL速度慢吗**：HTTPS存在的问题：使用SSL时，除去和TCP连接、发送HTTP请求、响应以外，还必须进行SSL通信，因此整体上处理通信量不可避免会增加。另一点是SSL必须进行加密处理，在服务器和客户端都需要进行加密和解密的运算处理，因此从结果上讲，比起HTTP会更多地消耗服务器和客户端地硬件资源，导致负载增强；

**为什么不一直使用HTTPS**：1.与纯文本通信相比，加密通信会消耗更多的CPU及内存资源；2.节约购买证书的开销；

## 确认访问用户身份的认证

HTTP/1.1使用的认证方式：BASIC认证（基本认证）、DIGEST认证（摘要认证）、SSL客户端认证、FormBase认证（基于表单认证），此外还有Windows统一认证（Keberos认证、NTLM认证）；

### Basic认证

Basic认证是从HTTP/1.0就定义的认证方式，即便是现在仍有一部分的网站会使用这种认证方式，是Web服务器与通信客户端之间进行的认证方式；

1. 当请求的资源需要Basic认证时，服务器会随状态码401 Authorization Required，返回带WWW-Authenticate首部字段的响应，该字段内包含认证的方式（BASIC）及Request-URI安全域字符串（realm）；
2. 接收到状态码401的客户端为了通过Basic认证，需要讲用户ID及密码发送给服务器，发送的字符串内容是由用户ID和密码构成，两者中间以冒号连接后，再经过Base64编码处理；
3. 接收到包含首部字段Authorization请求的服务器，会对认证信息的正确性进行验证，如果验证通过，则返回一条包含Request-URI资源的响应；

### DIGEST认证

- DIGEST认证使用质询/响应（challenge/response，一开始一方会发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码，最后将响应码返回给对方进行认证的方式）的方式，但不会像BASIC那样直接发送明文密码；
- DIGEST认证提供了高于BASIC认证的安全等级，但是和HTTPS的客户端认证相比仍旧很弱。DIGEST认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制；

### SSL客户端认证

从使用用户id和密码的认证方式方面来讲，只要二者的内容正确，即可认证是本人的行为，但是如果用户id和密码被盗，就很有可能被第三者冒充。利用SSL客户端认证则可以避免该情况的发生；

#### SSL客户端认证的认证步骤

为达到SSL客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书；

1. 接收到需要认证资源的请求，服务器会发送Certificate Request报文，要求客户端提供客户端证书；
2. 用户选择将发送的客户端证书后，客户端会把客户端证书信息以Client Certificate报文方式发送给服务器；
3. 服务器验证客户端证书，验证通过后方可领取证书内客户端的公开密钥，然后开始HTTPS加密通信；

#### SSL客户端认证采用双因素认证

在多数情况下，SSL客户端认证不会仅依靠证书完成认证，一般会和基于表单认证组合形成一种双因素认证来使用。即SSL客户端证书用来认证客户端计算机，密码用来确认这个用户本人的行为；

### 基于表单认证

基于表单的认证方法并不是在HTTP协议中定义的。客户端会向服务器上的Web应用发送登录信息，按登录信息的验证结果认证。

#### 认证多半为基于表单认证

由于使用上的便利性及安全性问题，HTTP协议标准提供的BASIC认证和DIGEST认证几乎不怎么使用，另外SSL客户端认证虽然有高度的安全等级，但是因为导入及维持费用等问题，还尚未普及。对于Web网站的认证功能，能够满足其安全使用级别的标准规范并不存在，所以只好使用由Web应用程序各自实现基于表单的认证方式；

#### Session管理及Cookie应用

基于表单认证的标准规范尚未有定论，一般会使用Cookie来管理Session。鉴于HTTP是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来，于是我们会使用Cookie来管理Session，以弥补HTTP协议中不存在的状态管理功能；

1. 客户端把用户ID和密码等登录信息放入报文的实体部分，通常是以POST方法把请求发送给服务器；
2. 服务器会发放用以识别用户的SessionID，通过验证从客户端发送过来的登录信息进行身份验证，然后把用户的认证状态与SessionID绑定后记录在服务器端。然而，如果SessionID被第三方盗走，对方就可以伪装成你的身份进行恶意操作了，因此必须防止SessionID被盗或被猜出。为了做到这点SessionID应使用难以推测的字符串，且服务器端也需要进行有效期管理，保证其安全性。为减轻跨站脚本攻击（XSS）造成的损失，建议事先在Cookie内加上httponly属性；
3. 客户端接收到从服务器端发来的SessionID后，会将其作为Cookie保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以SessionID也随之发送到服务器。服务器端可通过验证接收到的SessionID识别用户和其认证状态；

**密码保存**

- 不仅基于表单认证的的登录信息及认证过程都无标准化的方法，服务器端应如何保存用户提交的密码等登录信息也没有标准化；
- 通常，一种安全的保存方法是先利用给密码加盐的方式增加额外信息，再利用散列函数计算出散列值后保存；

## 基于HTTP的功能追加协议

### 消除HTTP瓶颈的SPDY

SPDY的开发目标旨在解决HTTP的性能瓶颈，缩短Web页面的加载时间（50%）；

#### HTTP的瓶颈

- 对于Facebook、Twitter这类的网站，为了尽可能实时地显示这些更新的内容，服务器上一有内容更新，就需要直接把那些内容反馈到客户端的界面上，而HTTP无法妥善地处理好这项任务；
- 使用HTTP协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器端进行确认，如果服务器上没有内容更新，那么就会产品徒劳的通信；

此场景下以下HTTP标准就会称为瓶颈：

- 一条连接上只可发送一个请求；
- 请求只能从客户端开始，客户端不可以接收除响应以外的指定；
- 请求/响应首部未经压缩就发送，首部信息越多延迟越大；
- 发送冗长的首部，每次互相发送相同的首部造成的浪费较多；
- 可任意选择数据压缩格式，非强制压缩发送；

**Ajax的解决办法**

- Ajax（Asynchronous JavaScript and XML）是一种有效利用JavaScript和DOM（Document Object Model）的操作，以达到局部Web页面替换加载的异步通信手段；
- Ajax的核心技术是名为XMLHttpRequest的API，通过JavaScript脚本语言的调用就能和服务器进行HTTP通信。借由这种手段，就能从已加载完毕的Web页面上发起请求，只更新局部页面；
- 而利用Ajax实时地从服务器获取内容，有可能会导致大量请求产生，另外Ajax仍未解决HTTP协议本身存在的问题；

**Comet的解决方法**

- 一旦服务器端有内容更新了，Comet不会让请求等待，而是直接给客户端返回响应，这是一种通过延迟应答，模拟实现服务器端向客户端推送（Server Push）的功能；
- 通常服务器端接收到请求，在处理完毕后就会立即返回响应，但是为了实现推送功能，Coment会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。因此服务器端一旦有更新，就可以立即反馈给客户端；
- 内容上虽然可以做到实时更新，但是为了保留响应，一次连接的持续时间也变长了。期间为了维持连接会消耗更多的资源。另外Comet也仍未解决HTTP协议本身存在的问题；

#### SPDY的设计和功能

SPDY没有完全改写HTTP协议，而是在TCP/IP的应用层与传输层之间通过新加会话层的形式运作，同时SPDY规定通信中使用SSL。SPDY以会话层的形式加入，控制对数据的流动。因此可照常使用HTTP的GET和POST等方法、Cookie以及HTTP报文等。使用SPDY后，HTTP协议额外获得以下功能：

- **多路复用流**：通过单一的TCP连接，无限制处理多个HTTP请求，所有请求的处理都在一条TCP连接上完成，因此TCP的处理效率得到提高；
- **赋予请求优先级**：可以给请求逐个分配优先级顺序，在发送多个请求时，解决因带宽低而导致的响应变慢的问题；
- **压缩HTTP首部**：压缩HTTP请求和响应首部，使通信产品的数据包数量和发送的字节数更少了；
- **推送功能**：支持服务器主动向客户端推送数据的功能；
- **服务器提示功能**：服务器可以主动提示客户端请求所需的资源，由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求；

### 使用浏览器进行全双工通信的WebSocket

利用Ajax和Comet技术进行通信可以提升Web的浏览速度，但问题在于通信若使用HTTP协议，就无法彻底解决瓶颈问题。WebSocket网络技术正是为解决这些问题而实现的一套新协议及API；

#### WebSocket的设计与功能

WebSocket即Web浏览器与Web服务器之间全双工通信标准。

#### WebSocket协议

主要特点：

**推送功能**：支持服务器向客户端推送数据；

**减少通信量**：只要建立起WebSocket连接，就希望一直保持连接状态，和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也减少了；

为了实现WebSocket通信，在HTTP连接建立之后，需要完成一次握手的步骤：

- 握手请求：为了实现WebSocket通信，需要用到HTTP的Upgrade首部字段，告知服务器通信协议发生，以达到握手的目的；
- 握手响应：对于之前的请求，返回状态码101 Switching Protocols的响应。成功握手确立WebSocket连接之后，通信时不再使用HTTP的数据帧，而使用WebSocket独立的数据帧；

### 期盼已久的HTTP/2.0

随着SPDY和WebSocket等技术纷纷出现，很难断言HTTP/1.1仍是适用于当前的Web的协议

HTTP/2.0围绕着主要的7项技术进行讨论：

| 技术                                                  | 实现                       |
| ----------------------------------------------------- | -------------------------- |
| 压缩                                                  | SPDY、Friendly             |
| 多路复用                                              | SPDY                       |
| TLS义务化                                             | Speed + Mobility           |
| 协商                                                  | Speed + Mobility，Friendly |
| 客户端拉拽（Client Pull） / 服务器推送（Server Push） | Speed + Mobility           |
| 流量控制                                              | SPDY                       |
| WebSocket                                             | Speed + Mobility           |

HTTP Speed + Mobility是用于改善并提高移动端通信时的通信速度和性能的标准，建立在SPDY与WebSocket基础之上，Network-Friendly Upgrade主题是在移动端通信时改善HTTP性能的标准；

### Web服务器管理文件的WebDAV

- WebDAV（Web）是一个可对Web服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。除了创建、删除文件，它还具备文件创建者管理、文件编辑过程中禁止其他用户内容覆盖的加锁功能，以及对文件内容修改的版本控制功能。
- 使用HTTP/1.1的PUT方法和DELETE方法，就可以对Web服务器上的文件进行创建和删除操作，可是处于安全性及便捷性等考虑，一般不使用。

#### 扩展HTTP/1.1的WebDAV

- 针对服务器上的资源，WebDAV新增加了一些概念，如下：
- 集合（Collection）：统一管理多个资源的概念；
- 资源（Resource）：把文件或集合称为资源；
- 属性（Property）：定义资源的属性；
- 锁（Lock）：把文件设置成无法编辑状态，多人同时编辑时，可防止在同一时间进行内容写入；

#### WebDAV内新增的方法及状态码

WebDAV为实现远程文件管理，向HTTP/1.1中追加了以下这些方法：

- PROPFIND：获取属性
- PROPPATCH：修改属性
- MKCOL：创建集合
- COPY：复制资源及属性
- MOVE：移动资源
- LOCK：资源加锁
- UNLOCK：资源解锁

为配合扩展的方法，状态码也随之扩展：

- 102 Processing：可正常处理请求，但是目前是处理中状态；
- 207 Multi-Status：存在多种状态；
- 422 Unprocessible Entity：格式正确，内容有误；
- 423 Locked：资源已被加锁；
- 424 Failed Dependency：处理与某请求关联的请求失败，因此不再维持依赖关系；
- 507 Insufficient Storage：保存空间不足；

### 为何HTTP协议受众如此广泛

- 与防火墙有关：防火墙的基本功能就算禁止非指定的协议和端口号的数据包通过，因此使用新协议或端口号必须修改防火墙设置。在构建Web服务器或访问Web站点时，需事先设置防火墙HTTP（80/tcp）和HTTPS（443/tcp）的权限；
- 客户端：作为HTTP客户端的浏览器已相当普遍；

## 构建Web内容的技术

### 数据发布的格式及语言

#### 可扩展性标记语言

- XML（eXtensible Markup Language，可扩展标记语言）是一种可按应用目标进行扩展的通用标记语言，旨在通过使用XML，使互联网数据共享变得更容易；
- 更容易地复用数据的特点使得XML在互联网上被广泛接收，比如可用于2个不同的应用之间的交换数据格式化；

#### 发布更新信息的RSS/Atom

- RSS（简易信息聚合）和Atom都是发布新闻或博客日志等更新信息文档的格式的总称，两者都用到了XML；
- Atom供稿格式（Atom Syndication Format）：为发布内容而制定的网站消息来源格式；
- Atom出版协定（Atom Publishing Protocol）：为Web上内容的新增或修改而制定的协议；

#### JavaScript衍生的轻量级易用JSON

JSON（JavaScript Object Notation）是一种以JavaScript的对象表示法为基础的轻量级数据标记语言。能够处理的数据类型有false/null/true/对象/数组/数字/字符串这7种类型

## Web的攻击技术

### 针对Web的攻击技术

简单的HTTP协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击的对象，应用HTTP协议的服务器和客户端以及运行在服务器上的Web应用等资源才是攻击目标；

#### HTTP不具备必要的安全功能

#### 在客户端即可篡改请求

- 在Web应用中，从浏览器那接收到的HTTP请求的全部内容，都可以在客户端自由地变更，篡改，所以Web应用可能会接收到与预期数据不相同的内容；
- 在HTTP请求报文内加载攻击代码，就能发起对Web应用的攻击。通过URL查询字段或表单、HTTP首部、Cookie等途径把攻击代码传入，若这是Web应用存在安全漏洞，那内部信息就会遭到窃取，或被攻击者拿到管理权限；

#### 针对Web应用的攻击模式

**以服务器为目标的主动攻击**

主动攻击是指攻击者通过访问Web应用，把攻击代码传入的攻击模块。其具有代表性的是SQL注入攻击和OS命令注入攻击；

**以服务器为目标的被动攻击**

被动攻击是指利用全套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者不直接对目标Web应用访问发起攻击，其通常的攻击模式如下：

1. 攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的HTTP请求；
2. 当用户不知不觉中招后，用户的浏览器或邮件客户端就会触发这个陷阱；
3. 中招后的用户浏览器就会把含有攻击代码的HTTP请求发送给作为攻击目标的Web应用，运行攻击代码；
4. 执行完攻击代码，存在安全漏洞的Web应用会成为攻击者的跳板，可能导致用户所持的Cookie等个人信息被窃取；

被动攻击中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造；

### 因输出值转义不完全引发的安全漏洞

实施Web应用的安全对策可大致分为：

- 客户端的验证；
- Web应用端（服务器端）的验证：输入值验证、输出值转义；

多数情况下采用JavaScript在客户端验证数据，可是在客户端允许篡改数据或关闭JavaScript，所以不能把JavaScript验证作为安全的防范对策；

Web应用端的输入值验证按Web应用内的处理则有可能被误认为是具有攻击意义的代码，输入值验证通常是指检查是否是符合系统业务逻辑的数值或检查字符编码等预防对策；

#### 跨站脚本攻击

跨站脚本攻击（Cross-Site Scripting， XSS）是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击；

#### SQL注入攻击

SQL注入（SQL Injection）是指针对Web应用使用的数据库，通过运行非法的SQL而产生的攻击，该安全隐患有可能引发极大的威胁，有时直接导致个人信息及机密信息的泄漏；

SQL注入攻击有可能会造成以下等影响：

- 非法查看或篡改数据库内的数据；
- 规避认证；
- 执行和数据库业务关联的程序；

#### OS命令注入攻击

OS命令注入攻击（OS Command Injection）是指通过Web应用，执行非法的操作系统命令达到攻击的目的；

#### HTTP首部注入攻击

HTTP首部注入攻击（HTTP Header Injection）是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击，属于被动攻击模式。

HTTP首部注入攻击有可能会造成以下影响：

- 设置任何Cookie信息；
- 重定向至任意URL；
- 显示任意的主体（HTTP响应截断攻击）；

#### 邮件首部注入攻击

邮件首部注入是指Web应用中邮件发送功能，攻击者通过向邮件首部To或Subject内任意添加非法内容发起的攻击。利用存在安全漏洞的Web网站，可对任意邮件地址发送广告邮件或病毒邮件；

#### 目录遍历攻击

目录遍历攻击是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击，这种攻击有时也称为路径遍历攻击；

#### 远程文件包含漏洞

远程文件包含漏洞（Remote File Inclusion）是指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，让脚本读取后，就可以运行任意脚本的一种攻击；

### 因设置或设计上的缺陷引发的安全漏洞

#### 强制浏览

强制浏览安全漏洞是指，从安置在Web服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件；

#### 不正确的错误消息处理

不正确的错误消息处理的安全漏洞是指，Web应用的错误信息内包含对攻击者有用的信息，与Web应用有关的主要错误信息如下：

- Web应用抛出的错误消息；
- 数据库等系统抛出的错误消息；

Web应用不必在用户的浏览画面上展示详细的错误消息，对攻击者来说，详细的错误消息有可能给他们下一次攻击以提示；

#### 开放重定向

开放重定向（Open Redirect）是一种对指定的URL作重定向跳转的功能，而与此功能的相关的安全漏洞是指，假如指定的重定向URL到某个恶意的Web网站，那么用户就会被诱导至那个Web网站。

### 因会话管理疏忽引发的安全漏洞

#### 会话劫持

会话劫持（Session Hijack）是指攻击者通过某种手段拿到了用户的会话ID，并非法使用此会话ID伪装成用户，达到攻击的目的。

#### 会话固定攻击

会话固定攻击（Session Fixation）会强制用户使用攻击者指定的会话ID，属于被动攻击

#### 跨站点请求伪造

跨站点请求伪造（Cross-Site Request Forgeries，CSRF）攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。

### 其他安全漏洞

#### 密码破解

密码破解攻击即算出密码，突破认证

#### 点击劫持

利用透明的按钮或链接做成陷阱，覆盖在Web页面之上。然后诱导用户在不知情的情况下点击那个链接访问内容的一种攻击手段，这种行为又被称为界面伪装；

#### DoS攻击

DoS攻击是一种让运行中的服务呈停止状态的攻击，有时也叫服务停止攻击或拒绝服务攻击。Dos攻击的对象不仅限于Web网站，好包括网络设备及服务器等。

主要有两种DoS攻击方式：

- 集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈停止状态；
- 通过攻击安全漏洞使服务停止；

多台计算机发起的DoS攻击称为DDoS攻击（Distributed Denial of Service attack），DDoS攻击通常利用那些感染病毒的计算机作为攻击者的跳板。

#### 后门程序

后门程序是指开发设置的隐藏入口，可不安正常步骤使用受限功能，利用后门程序就能够使用原本受限制的功能；