# Redis的设计与实现

## 简单动态字符串

### SDS（Simple Dynamic String）的定义

**结构**

- len: 记录buf数组已使用字节的数量；
- free: 记录未使用字节的数量；
- buf[]：保存字符串；

SDS以空字符'\0'结尾，这个字符对使用者完全透明；

### SDS与C字符串的区别

#### 常数复杂度获取字符串长度

C字符串不保存字符串长度，获取长度时需遍历字符串，而SDS则是通过len保存了；

#### 杜绝缓冲区溢出

C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出，而SDS的API在对SDS修改时会先确保空间是足够的，从而杜绝缓冲区溢出；

### 减少修改字符串时带来的内存重分配次数

如果增长或缩短一个C字符串，程序总要对保存这个C字符串的数组进行一次内存重分配的操作；

SDS通过未使用空间解除了字符串长度与底层数组长度之间的关联。SDS实现了空间预分配和惰性空间释放两种优化策略：

- 空间预分配：即SDS的API对SDS增长时，会按一定策略进行扩容；
- 惰性空间释放：当SDS的API需要缩短其保存的字符串时，会使用free属性记录可用的字节数量供后续使用，同时也提供了API用来真正地释放SDS的未使用空间；

#### 二进制安全

- C字符串的字符必须符合某种编码，并且除了末尾不能包含空字符，因而不能保存图片、音频等二进制数据；
- SDS的API都是二进制安全的，即所有API都会以处理二进制的方式来处理SDS存放的数据，不会对其中的数据做任何限制、过滤等；

#### 兼容部分C字符串函数

由于SDS遵循了C字符串的以空字符串结尾的惯例，SDS可以重用一部分C字符串函数库里的函数

## 链表

### 链表和链表节点的实现

- 链表的每个节点使用listNode结构表示，它包含前置节点指针prev，后置节点指针next，节点的值value三个属性；
- 使用list结构持有链表比使用listNode更方便，它包含了头节点head、尾节点tail、链表长度计数器len这三个属性，以及节点值复制函数dup、节点值释放函数free、节点值对比函数match；

### 总结

- 链表被广泛用于实现Redis的各种功能，如列表键、发布订阅、慢查询、监视器等；
- Redis的链表实现是双端无环链表；
- 通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值；

## 字典

字典在Redis中的应用相当广泛，Redis数据库就是使用字段作为底层实现的，对数据库的增删查改操作也是构建在对字典的操作之上；

### 字典的实现

Redis的字段使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，每个哈希表节点保存了字典中的一个键值对；

#### 哈希表

哈希表由dict.h/dictht结构定义

```c
typedef struct dictht {
    // 哈希表数组
    dictEntry **table;
    // 哈希表大小
    unsigned long size;
    // 哈希表大小验码，用于计算索引值，总是等于size - 1
    unsigned long sizemask;
    // 哈希表已有的节点数量
    unsigned long used;
} dictht;
```

#### 哈希表节点

- 哈希表节点使用dictEntry结构，每个dictEntry都保存着一个键值对，并且包含一个next指针；
- next属性指向另一个哈希表节点，这个指针将多个哈希值相同的键值对连接在一起，以此解决键冲突的问题（即链地址法）；

#### 字典

Redis的字典由dict.h/dict结构表示

```c
typedef struct dict {
    // 类型特定函数
    dictType *type;
    // 私有数据
    void *privdata;
    // 哈希表
    dictht ht[2];
    // rehash索引，当rehash不在进行时，值为-1
    int rehashidx;
} dict;
```

- type属性和privdata属性是怎对不同类型的键值对，为创建多态字典而设置的；
- ht属性包含两个哈希表，一般情况下字典只使用ht[0]哈希表，ht[1]的哈希表只在对ht[0]进行rehash时使用；
- rehashidx记录了rehash目前的进度，如果当前没有进行rehash，则值为-1；

### rehash

1. 为ht[1]哈希表分配空间，如果执行扩展操作，则ht[1]的大小为第一个大于等于ht[0].used*2的2的n次幂，如果是收缩操作，则ht[1]的大小为第一个大于等于ht[0].used的2的n次幂；
2. 将保存在ht[0]中的所有键值对重新计算哈希值和索引值，放置到ht[1]哈希表的指定位置上；
3. ht[0]迁移完毕后，释放空间，将ht[1]设置为ht[0]，并在ht[1]创建一个空白哈希表，准备下一次rehash；

### 渐进式rehash

当hash表非常大时，为了避免rehash对服务器性能造成影响，服务器会分多次、渐进式地将ht[0]里面地键值对慢慢地rehash到ht[1]。其步骤为：

- 为ht[1]分配空间；
- 把rehashidx设置为0，表示rehash工作正式开始；
- 在rehash进行期间，每次对字典进行增删查改操作时，程序除了指定操作外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash完成后，rehashidx加一；
- 随着字段操作的不断执行，最终所有键值对都会被rehash至ht[1]，这时将rehashidx设置为-1，表示rehash操作已完成；

渐进式rehash期间对字段的删除、查找、更新会在两个哈希表上进行，新增的键值对则保存到ht[1]中；

## 跳跃表

- 跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的；
- 跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树更简单，所有不少程序都使用跳跃表代替平衡树；
- Redis使用跳跃表作为有序集合键ZSet的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。此外，Redis还在集合节点中应用到了跳跃表；

### 跳跃表的实现











