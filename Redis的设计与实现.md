# Redis的设计与实现

## 简单动态字符串

### SDS（Simple Dynamic String）的定义

**结构**

- len: 记录buf数组已使用字节的数量；
- free: 记录未使用字节的数量；
- buf[]：保存字符串；

SDS以空字符'\0'结尾，这个字符对使用者完全透明；

### SDS与C字符串的区别

#### 常数复杂度获取字符串长度

C字符串不保存字符串长度，获取长度时需遍历字符串，而SDS则是通过len保存了；

#### 杜绝缓冲区溢出

C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出，而SDS的API在对SDS修改时会先确保空间是足够的，从而杜绝缓冲区溢出；

### 减少修改字符串时带来的内存重分配次数

如果增长或缩短一个C字符串，程序总要对保存这个C字符串的数组进行一次内存重分配的操作；

SDS通过未使用空间解除了字符串长度与底层数组长度之间的关联。SDS实现了空间预分配和惰性空间释放两种优化策略：

- 空间预分配：即SDS的API对SDS增长时，会按一定策略进行扩容；
- 惰性空间释放：当SDS的API需要缩短其保存的字符串时，会使用free属性记录可用的字节数量供后续使用，同时也提供了API用来真正地释放SDS的未使用空间；

#### 二进制安全

- C字符串的字符必须符合某种编码，并且除了末尾不能包含空字符，因而不能保存图片、音频等二进制数据；
- SDS的API都是二进制安全的，即所有API都会以处理二进制的方式来处理SDS存放的数据，不会对其中的数据做任何限制、过滤等；

#### 兼容部分C字符串函数

由于SDS遵循了C字符串的以空字符串结尾的惯例，SDS可以重用一部分C字符串函数库里的函数

## 链表

### 链表和链表节点的实现

- 链表的每个节点使用listNode结构表示，它包含前置节点指针prev，后置节点指针next，节点的值value三个属性；
- 使用list结构持有链表比使用listNode更方便，它包含了头节点head、尾节点tail、链表长度计数器len这三个属性，以及节点值复制函数dup、节点值释放函数free、节点值对比函数match；

### 总结

- 链表被广泛用于实现Redis的各种功能，如列表键、发布订阅、慢查询、监视器等；
- Redis的链表实现是双端无环链表；
- 通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值；

## 字典

字典在Redis中的应用相当广泛，Redis数据库就是使用字段作为底层实现的，对数据库的增删查改操作也是构建在对字典的操作之上；

### 字典的实现

Redis的字段使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，每个哈希表节点保存了字典中的一个键值对；

#### 哈希表

哈希表由dict.h/dictht结构定义

```c
typedef struct dictht {
    // 哈希表数组
    dictEntry **table;
    // 哈希表大小
    unsigned long size;
    // 哈希表大小验码，用于计算索引值，总是等于size - 1
    unsigned long sizemask;
    // 哈希表已有的节点数量
    unsigned long used;
} dictht;
```

#### 哈希表节点

- 哈希表节点使用dictEntry结构，每个dictEntry都保存着一个键值对，并且包含一个next指针；
- next属性指向另一个哈希表节点，这个指针将多个哈希值相同的键值对连接在一起，以此解决键冲突的问题（即链地址法）；

#### 字典

Redis的字典由dict.h/dict结构表示

```c
typedef struct dict {
    // 类型特定函数
    dictType *type;
    // 私有数据
    void *privdata;
    // 哈希表
    dictht ht[2];
    // rehash索引，当rehash不在进行时，值为-1
    int rehashidx;
} dict;
```

- type属性和privdata属性是怎对不同类型的键值对，为创建多态字典而设置的；
- ht属性包含两个哈希表，一般情况下字典只使用ht[0]哈希表，ht[1]的哈希表只在对ht[0]进行rehash时使用；
- rehashidx记录了rehash目前的进度，如果当前没有进行rehash，则值为-1；

### rehash

1. 为ht[1]哈希表分配空间，如果执行扩展操作，则ht[1]的大小为第一个大于等于ht[0].used*2的2的n次幂，如果是收缩操作，则ht[1]的大小为第一个大于等于ht[0].used的2的n次幂；
2. 将保存在ht[0]中的所有键值对重新计算哈希值和索引值，放置到ht[1]哈希表的指定位置上；
3. ht[0]迁移完毕后，释放空间，将ht[1]设置为ht[0]，并在ht[1]创建一个空白哈希表，准备下一次rehash；

### 渐进式rehash

当hash表非常大时，为了避免rehash对服务器性能造成影响，服务器会分多次、渐进式地将ht[0]里面地键值对慢慢地rehash到ht[1]。其步骤为：

- 为ht[1]分配空间；
- 把rehashidx设置为0，表示rehash工作正式开始；
- 在rehash进行期间，每次对字典进行增删查改操作时，程序除了指定操作外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash完成后，rehashidx加一；
- 随着字段操作的不断执行，最终所有键值对都会被rehash至ht[1]，这时将rehashidx设置为-1，表示rehash操作已完成；

渐进式rehash期间对字段的删除、查找、更新会在两个哈希表上进行，新增的键值对则保存到ht[1]中；

## 跳跃表

跳跃表就是链表加多级索引结构

- 跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的；
- 跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树更简单，所有不少程序都使用跳跃表代替平衡树；
- Redis使用跳跃表作为有序集合键ZSet的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。此外，Redis还在集合节点中应用到了跳跃表；

### 跳跃表的实现

Redis的跳跃表由zskiplistNode和zskiplist两个结构定义，zskiplistNode用于表示跳跃表节点，zskiplist用于保存跳跃表节点的相关信息；

#### 跳跃表节点zskiplistNode

```c
struct zskiplistNode {
    // 层，每层都有一个前进指针和跨度
    struct zskiplistLevel {
        // 前进指针
        struct zskiplistNode *forward;
        // 跨度: 前进指针指向的层的节点和当前节点的距离
        unsigned int span;
    } level []; // 每个节点有多个层
    // 后退指针: 节点中用BW标记，指向位于当前节点的前一个节点
    struct zskiplistNode *backward;
    // 分值: 每个节点保存一个分值，节点按分值大小由小到大排序
    double score;
    // 成员对象: 每个节点保存的成员对象
    robj *obj;
} zskiplistNode;
```

**层**

- 每个层都包含一个指向其他节点的指针，层的数量越多，访问其他节点的速度就越快，因为在查找节点时，减少了需要遍历的节点的数量（如果是普通链表，查询效率为O(N)，跳跃表则可以跳过一部分节点）；
- 每次创建新的zskiplistNode时，程序都根据幂次定律随机生成一个1~32之间的值作为level数组的大小，这个大小就是层的高度；

**前进指针**

用于从表头向表尾遍历节点

**跨度**

跨度用于计算排位，在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位；

**后退指针**

用于从表尾向表头方向访问节点

**分值和成员**

- 跳跃表中所有节点都按分值从小到大排序，分值相同时按成员对象在字典序中的大小排序；
- 节点的成员对象obj是一个指针，指向一个字符串对象，字符串对象保存着一个SDS值；

#### 跳跃表

zskiplist包含访问跳跃表的表头节点head和表尾节点tail，表中节点的数量length和表中层数最大的节点的层数level（表头节点的层高不计算在内）；

## 整数集合

整数集合（intset）是集合键（set）的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现；

### 整数集合的实现

整数集合intset是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或int64_t的整数值，并且保证集合中不会出现重复元素；

```c
typedef struct intset {
    // 编码方式，决定了contents数组的真正类型
    uint32_t encoding;
    // 集合包含的元素数量
    uint32_t length;
    // 保存元素的数组 ，数组中按值的大小从小到大排列，并且数组不包含任何重复项
    int8_t contents[];
} intset;
```

### 升级

- 当添加新元素时，如果新元素的类型比整数集合现有所有元素的类型都要长时，需进行升级（扩展空空间，将所有元素转换为新元素的类型）；
- 升级策略提升了整数集合的灵活性，尽可能地节约了内存（没有直接选择全部用int64实现）；

### 降级

不支持

## 压缩列表

压缩列表ziplist是list和hash的底层实现之一，当列表键只包含少量列表项，并且每个列表项要么是小整数值，要么是短字符串，则Redis会使用压缩列表作为列表键的底层实现；

### 压缩列表的构成

压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或一个整数值；

| 属性    | 类型     | 长度  | 用途                                      |
| ------- | -------- | ----- | ----------------------------------------- |
| zlbytes | uint32_t | 4字节 | 记录整个压缩列表的内存字节数              |
| zltail  | uint32_t | 4字节 | 记录压缩列表尾节点距离起始地址有多少字节  |
| zllen   | uint16_t | 2字节 | 记录压缩列表包含的节点数量                |
| entryX  | 列表节点 | 不定  | 压缩列表中的各个节点                      |
| zlend   | uint8_t  | 1字节 | 特殊值0xFF（255），用于标记压缩列表的末端 |

### 压缩列表节点的构成

每个压缩列表节点可以保存一个字节数组或一个整数值，压缩节点都由previous_entry_length、encoding、content三个部分组成；

#### previous_entry_length

- 以字节为单位，记录前一个节点的长度，如果前一个节点的长度小于254字节，那么previous_entry_length属性的长度为1字节，如果大于等于254字节，则长度为5字节；
- 通过当前节点起始地址和previous_entry_length，就可以计算出前一个节点的起始地址，压缩列表从尾到头遍历操作就是使用这一原理实现的；

#### encoding

节点encoding属性记录了节点的content属性所保存数据的类型及长度；

#### content

节点content属性负责保存节点的值，节点值可以是一个字节数组或整数，值的类型和长度由节点的encoding属性决定；

### 连锁更新

- 如果压缩列表里有多个连续的、长度介于250字节至253字节之间的节点，则插入删除节点可能会引发连锁更新；
- 其出现概率非常小，且即使出现了，只要数量不多，也不会有性能问题；

## 对象

### 对象的类型与编码

每次在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），一个用作键值对的值（值对象）；

Redis中每个对象都由一个redisObject结构表示：

```c
typedef struct redisObject {
    // 类型
    unsigned type:4;
    // 编码
    unsigned encoding:4;
    // 指向底层实现数据结构的指针
    void *ptr;
} robj;
```

#### 类型

对于Redis保存的键值对，其键总是一个字符串对象，而值可以是：

| 类型常量     | 对象         |
| ------------ | ------------ |
| REDIS_STRING | 字符串对象   |
| REDIS_LIST   | 列表对象     |
| REDIS_HASH   | 哈希对象     |
| REDIS_SET    | 集合对象     |
| REDIS_ZSET   | 有序集合对象 |

#### 编码和底层实现

对象的ptr指针指向对象的底层实现数据结构，这些数据结构由对象的encoding属性决定：

| 编码常量                  | 编码对应的底层数据结构     |
| ------------------------- | -------------------------- |
| REDIS_ENCODING_INT        | long类型的整数             |
| REDIS_ENCODING_EMBSTR     | embstr编码的简单动态字符串 |
| REDIS_ENCODING_RAW        | 简单动态字符串             |
| REDIS_ENCODING_HT         | 字典                       |
| REDIS_ENCODING_LINKEDLIST | 双端链表                   |
| REDIS_ENCODING_ZIPLIST    | 压缩列表                   |
| REDIS_ENCODING_INTSET     | 整数集合                   |
| REDIS_ENCODING_SKIPLIST   | 跳跃表和字典               |

每种类型的对象都至少使用两种不同的编码：

| 类型         | 编码                                                         |
| ------------ | ------------------------------------------------------------ |
| REDIS_STRING | REDIS_ENCODING_INT、REDIS_ENCODING_EMBSTR、REDIS_ENCODING_RAW |
| REDIS_LIST   | REDIS_ENCODING_ZIPLIST、REDIS_ENCODING_LINKEDLIST            |
| REDIS_HASH   | REDIS_ENCODING_ZIPLIST、REDIS_ENCODING_HT                    |
| REDIS_SET    | REDIS_ENCODING_INTSET、REDIS_ENCODING_HT                     |
| REDIS_ZSET   | REDIS_ENCODING_ZIPLIST、REDIS_ENCODING_SKIPLIST              |

### 字符串对象

- 当字符串对象保存的是一个long类型整数值时，其编码为int；
- 当保存的是小于等于32字节的字符串时，则使用embstr保存，编码设置为embstr；
- 当保存的是大于32字节的字符串时，则使用SDS保存，编码设置为raw；

#### 编码的转换

- int编码的对象，如果被执行了append，会变为raw；
- embstr编码的对象被执行任何修改命令后（因为embstr对象没有修改的API），都会转换成raw；

### 列表对象

#### 编码转换

当列表对象可以同时满足以下两个条件时，使用ziplist编码，如果不能满足，则使用linkedlist编码：

- 列表对象保存的所有字符串元素的长度都小于64字节；
- 列表对象保存的元素数量小于512个；

当使用ziplist编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行，原来保存在压缩列表的所有元素会被转移并保存到双端链表里，其编码也会变为linkedlist；

### 哈希对象

- 哈希对象的编码可以是ziplist或hashtable；
- 如果使用ziplist，则每当有新的键值对要加入到哈希对象时，程序会先将键的节点推入，再推入值的节点；
- 如果使用hashtable，则每个键值对都使用一个字典键值对来保存，字典的每个键/值都是一个字符串对象；

#### 编码转换

当哈希对象同时满足以下两个条件时，哈希对象使用ziplist编码，否则使用hashtable：

- 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；
- 键值对总数小于512个；

### 集合对象

- 集合对象的编码可以是intset或hashtable；
- 如果是hashtable编码的集合，则字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL；

#### 编码的转换

当集合对象满足以下两个条件时，使用intset编码，否则使用hashtable编码：

- 集合对象保存的所有元素都是整数值；
- 集合对象保存的元素数量不超过512个；

### 有序集合对象

- 有序集合的编码可以是ziplist或skiplist
- ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），第二个元素保存元素的分值（score）；
- skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表，zset中的跳跃表按分值从小到大保存了所有集合元素，字典则为有序集合创建了一个从成员到分值的映射（因此可以以O(1)的复杂度来查找成员的分值）；

#### 编码的转换

当有序集合对象同时满足以下两个条件时，对象使用ziplist编码，否则使用skiplist：

- 有序集合保存的元素数量小于128个；
- 有序集合保存的所有元素成员的长度都小于64字节；

### 类型检查与命令多态

Redis中用于操作键的命令基本上可以分为两种类型：

- 一种命令可以对任何类型的键执行，如DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等；
- 另一种命令只能对特定类型的键执行，比如SET、GET、APPEND等命令只能对字符串键执行，如果对某类型的键执行了不属于它的命令，则会返回一个类型错误；

#### 类型检查的实现

执行命令前先检查输入数据库键的值对象是否为执行命令所需的类型，如果不是则拒绝执行并返回一个类型错误；

#### 多态命令的实现

Redis除了会根据值对象的类型来判断键是否能够执行指定命令外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令

### 内存回收

C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数技术实现的内存回收机制，通过这一技术在适当的时候自动释放对象并进行内存回收；

### 对象共享

除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用（让多个键指向同一个对象）；

### 对象的空转时长

- 除了type、encoding、ptr和refcount四个属性，redisObject还包含一个lru属性，该属性记录了对象最后一次被命令程序访问的时间；
- OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的；
- 空转时长还有另外一项作用：如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或allkeys-lru，那么当服务器占用的内存数超过了maxmemory时，空转时长较高的那部分键会优先被服务器释放，从而回收内存；

## 数据库

### 服务器中的数据库

- Redis将所有数据库都保存在redisServer结构的db数组中，db数组的每一项都是一个redisDb结构，每个结构代表一个数据库；
- 初始化服务器时，程序会根据服务器状态的dbnum属性创建数据库，默认值为16；

### 切换数据库

每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或数据库读命令的时候，目标数据库就会成为这些命令的操作对象；

### 数据库键空间

- Redis是一个键值对数据库服务器，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）；
- 因为键空间是一个字典，所以所有针对数据库的操作，实际上都是通过对键空间进行操作来实现的；

### 设置键的生存时间或过期时间

通过EXPIRE命令或PEXPIRE命令，客户端可以以秒或毫秒精度为数据库中的某个键设置生存时间，在经过指定时间后，服务器就会自动删除生存时间为0的键；

#### 保存过期时间

- redisDB结构的expires字典保存了数据库中所有键的过期时间，我们称为为过期字典；
- 过期字典的键是一个指针，这个指针指向键空间中的某个键对象；
- 过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库的过期时间；

### 过期键删除策略

#### 定时删除

- 在设置键的过期时间的同事，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作；
- 对内存最友好（失效键不会占用空间），但是对CPU不友好；
- 创建一个定时器需要用到Redis服务器中的时间时间，当前时间事件的实现方式为无序链表，其查询时间复杂度为O(N)。因此要让服务器创建大量的定时器，在现阶段来说不现实；

#### 惰性删除

- 放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期，则删除该键，没过期则返回；
- 惰性删除对内存不友好；

#### 定期删除

每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键，至于删除多少过期键以及检查多个数据库，由算法决定；

### Redis的过期键删除策略

Redis使用的是惰性删除和定期删除两种策略，通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡；

#### 惰性删除的实现

过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查；

#### 定期删除策略的实现

过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键；

### 数据库通知

数据库通知功能可以让客户端通过订阅给定的频道或模式，来获知数据库中键的变化，以及数据库中命令的执行情况；

## RDB持久化



## AOF持久化



## 事件



## 客户端



## 服务器



## 复制

用户可以通过SLAVEOF命令或slaveof选项让一个服务器去复制另一个服务器，被复制的服务器为主服务器，进行复制的服务器被称为从服务器；

### 旧版（2.8版本以前）复制功能的实现

Redis的复制功能分为同步（sync）和命令传播（command propagate）两个操作：

- 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态；
- 命令传播则用于在主服务器的数据库状态被修改，导致主从数据库状态不一致时，让主从服务器的数据库重新回到一致状态；

#### 同步

从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令：

1. 从服务器向主服务器发送SYNC命令；
2. 收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令；
3. 当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态；
4. 主服务器将记录在缓冲区里的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前状态；

#### 命令传播

主服务器将自己执行的命令发送给从服务器执行；

### 旧版复制功能的缺陷

如果在命令传播阶段主从服务器因为网络原因而中断了，重连后从服务器需要重新发送SYNC命令进行同步，SYNC会消耗主服务器大量的CPU、内存和磁盘I/O资源；

### 新版复制功能的实现

Redis从2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步操作。PSYNC命令具有完整重同步和部分重同步两种模式：

- 完整重同步和SYNC基本一样：主服务器创建并发送RDB文件，以及向服务器发送保存在缓冲区的写命令；
- 部分重同步则用于处理短线后重新复制情况：当从服务器断线重连时，主服务器可以将主从服务器断开期间执行的写命令发送给从服务器，从服务器只要接收并执行了这些写命令，就可以将数据库更新至主服务器当前所处状态；

### 部分重同步的实现

部分重同步功能由三个部分构成：

#### 复制偏移量

- 主从服务器会分布维护一个复制偏移量；
- 主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量加N；
- 从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量加N；

#### 复制积压缓冲区

- 复制积压缓冲区是由主服务器维护的一个固定长度先进先出队列，默认为1MB；
- 当主服务器进行命令传播时，它不仅会将写命令发送给从服务器，还会将写命令入队到复制积压缓冲区里面，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量；
- 主服务器在收到PSYNC命令时，会判断从服务器的复制偏移量是否还存在于复制积压缓冲区中，如果存在，则执行部分重同步，如果不存在则执行完整重同步；

#### 服务器运行ID

每个Redis服务器都有自己的运行ID，从服务器进行初次复制时会保存主服务器的ID，发现断线重连时，从服务器会比较连接的主服务器ID是否发生变化，如果发生变化，则进行完整重同步，如果没有变化，则主服务器可以尝试执行部分重同步；

### 复制的实现

1. 通过SLAVEOF命令在从服务器上设置主服务器的地址和端口；
2. 从服务器根据命令所设置的IP地址和端口，创建连向主服务器的套接字连接。建立连接后从服务器会为这个套接字关联一个专门用于处理复制工作的文件事件处理器，这个处理器将负责执行后续的复制工作。而主服务器而是把从服务器看作是一个客户端来对待；
3. 从服务器成为主服务器的客户端之后，会向主服务器发送一个PING命令，如果主服务器回复一个PONG命令，则说明可以继续执行复制工作；
4. 在从服务器收到了PONG回复后，下一步要做的就是决定是否进行身份验证，如果从服务器设置masterauth选项，则进行身份验证；
5. 身份验证之后，从服务器执行命令REPLCONF listening-port <port-number>，向主服务器发送从服务器的监听端口号，主服务器在接收到这个命令之后，会将端口号记录在从服务器对应的客户端状态的slave_listening_port属性中；
6. 同步：从服务器向主服务器发送PSYNC命令，执行同步操作，并将自己的数据库更新至主服务器数据库当前所处的状态。同步之后，主服务器也会成为从服务器的客户端；
7. 命令传播：完成同步之后，主从服务器就会进入命令传播阶段，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就可以保证主从服务器一直保持一致了；

### 心跳检测

在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令REPLCONF ACK <replication_offset>，其中replication_offset是从服务器当前的复制偏移量，发送此命令对于主从服务器有三个作用：

- 检测主从服务器的网络连接状态；
- 辅助实现min-slaves选项：防止主服务器在不安全的情况下执行写命令，在从服务器数量少于一定数量，获取延迟大于一定值时，主服务器将拒绝执行写命令；
- 检测命令丢失；

## Sentinel（哨兵）

Sentinel（哨兵）是Redis的高可用性解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求；

### 启动并初始化Sentinel

1. 初始化服务器：Sentinel本质上只是一个运行在特殊模式下的Redis服务器，所以启动Sentinel的第一步，就是初始化一个普通的Redis服务器；
2. 将普通的Redis服务器使用的代码替换成Sentinel专用代码；
3. 初始化Sentinel状态：服务器初始化一个sentinelState结构，这个结构保存了服务器中所有和Sentinel功能有关的状态；
4. 根据给定的配置文件，初始化Sentinel的监视主服务器列表：Sentinel状态中的masters字典记录了所有被Sentinel监视的主服务器的相关信息，字典的键是被监视主服务器的名字，字典的值是被监视主服务器对应的sentinelRedisInstance结构；
5. 创建连向主服务器的网络连接：初始化Sentinel的最后一步是创建连向被监视主服务器的网络，Sentinel将成为u主服务器的客户端；

### 获取主服务器信息

Sentinel默认会以每十秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来获取主服务器的当前信息；

通过分析主服务器返回的INFO命令回复，Sentinel可以获取以下两方面信息：

- 主服务器本身的信息，包括run_id域记录的服务器运行id以及role域记录的服务器角色；
- 主服务器属下所有从服务器的信息；

### 获取从服务器信息

当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的从服务器创建相应的实例结构之外，Sentinel还会创建连接到从服务器的命令连接和订阅连接；

### 向主服务器和从服务器发送信息

- 默认情况下，Sentinel会以两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送命令；
- 这些信息主要是Sentinel的IP地址、端口号、runID、配置纪元（configuration epoch）及主服务器的名字、IP地址、端口号、配置纪元（configuration epoch）；

### 接收来自主服务器和从服务器的频道信息

- 当一个Sentinel与主服务器或者从服务器建立起订阅连接后，Sentinel就会通过订阅连接，向服务器发送订阅`__sentinel__:hello`频道的命令，也就是说Sentinel既向服务器的`__sentinel__:hello`频道发送消息，又通过订阅连接从服务器的`__sentinel__:hello`频道接收信息；
- 对于监视同一个服务器的多个Sentinel来说，一个Sentinel发送的信息会被其他Sentinel接收到，这些信息会被用于更新其他Sentinel对发送信息Sentinel的认知，也会被用于更新其他Sentinel对被监视服务器的认知；

#### 更新sentinels字典

Sentinel为主服务器创建的实例结构中的sentinels字段保存了其他监视这个主服务器的Sentinel的资料。当一个Sentinel接收到其他Sentinel发来的信息时，目标Sentinel会从信息中分析并提取出与Sentinel和主服务器有关的参数，并把这个信息更新到sentinels字典；

#### 创建连向其他Sentinel的命令连接

- 当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新的Sentinel在sentinels字典中创建相应的实例结构，还会创建一个连向新Sentinel的命令连接，新Sentinel同样也创建连向这个Sentinel的命令连接；
- 使用命令连接相连的各个Sentinel可以通过向其他Sentinel发送命令请求来进行信息交换；

### 检测主观下线状态

- 默认情况下，Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例发送PING命令，并通过实例返回的PING命令回复来判断实例是否在线；
- 如果一个实例在down-after-milliseconds毫秒内，连续向Sentinel返回无效回复，那么Sentinel会修改这个实例所对应的实例结构，在结构的flags属性中打开SRI_S_DOWN表示，以此表示这个实例已经进入主观下线状态；

### 检查客观下线状态

当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，它会向同样监视这一主服务器的其他Sentinel询问，如果从其他Sentinel那里接收到足够数量的已下线判断之后，Sentinel就会将从服务器判定为客观下线，并对主服务器执行故障转移操作；

### 选举领头Sentinel

- 当一个主服务器被判断为客观下线时，监视这个下线服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作；
- 每个发现主服务器客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel，最先向目标Sentinel发送设置要求的源Sentinel会成为目标Sentinel的局部领头Sentinel，之后接收到的所有设置要求都会被目标Sentinel拒绝；
- 如果有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel会成为领头Sentinel；

### 故障转移

1. 在已下线主服务器的从服务器里，挑选出一个从服务器，将其转换为主服务器（通过对其发送SLAVEOF no one命令）；
2. 让已下线主服务器属下的所有服务器改为复制新的主服务器（通过发送SLAVEOF命令）；
3. 将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器（通过发送SLAVEOF命令）；

## 集群

Redis集群是Redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能；

### 节点

- 一个Redis集群通常由多个节点组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群；
- 连接各个节点的工作可以通过CLUSTER MEET命令完成，该命令可以让node节点与ip和port所指定的节点进行握手，握手成功时，node节点就会将ip和port所指定的节点添加到node节点当前所在的集群中；

#### 启动节点

- 一个节点就是一个运行在集群模式下的Redis服务器，Redis服务器在启动时会根据cluster-enabled配置选项是否为yes来决定是否开启服务器的集群模式；
- 节点会使用redisServer结构来保存服务器状态，使用redisClient结构来保存客户端状态，那些只有在集群模式下会用到的数据，节点将它们保存到了clusterNode结构、clusterLink结构以及clusterState结构；

#### 集群数据结构

- clusterNode结构保存了一个节点的当前状态，比如节点的创建时间、名字、配置纪元、IP地址、端口号以及连接节点所需的有关信息（link）等；
- clusterNode结构的link属性是一个clusterLink结构，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区；
- 每个节点还保存着一个clusterState结构，这个结构记录了在当前节点的视角下，集群目前所处的状态，如集群是在线还是下线，包含多少个节点，集群当前的配置纪元等；

### 槽指派

Redis集群同过分片的方式保存数据库中的键值对，集群的整个数据库被分为16384个槽，数据库中的每个键都属于这16384个槽的其中一个。当数据库中的16384个槽都有节点在处理时，集群处于上线状态，相反如有任何一个槽没有得到处理，则处于下线状态；

### 记录节点的槽指派信息

- clusterNode结构的slots属性和numslot属性记录了节点负责处理哪些槽；
- slots属性是一个二进制位数组，这个数组的长度为16384/8=2048个字节，Redis根据索引i上的二进制位的值来判断节点是否负责处理槽i；
- numslot属性记录节点负责处理的槽的数量；

#### 传播节点的槽指派信息

- 一个节点除了会将自己负责处理的槽记录在clusterNode结构的slots属性和numslots属性之外，还会将字节的slots数组通过消息发送给集群中的其他节点，以此告知其他节点自己目前负责处理哪些槽；
- 集群中每个节点都会将自己的slots数组通过消息发送给集群中的其他节点，并且每个接收到slots数组的节点都会将数组保存到相应节点的clusterNode结构里，因此集群中的每个节点都会知道数据库中的16384个槽分别被指派给了集群中的哪些节点；

#### 记录集群所有槽的指派信息

clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息，slots数组包含16384个项，每个项都是一个指向clusterNode结构的指针；

### 在集群中执行命令

- 在对数据库中的16384个槽都进行了指派之后，集群就会进入上线状态，这是客户端就可以向集群中的节点发送数据命令了；
- 当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库属于哪个槽，并且检查这个槽是否指派了自己；
- 如果键所在的槽刚好是当前节点，则执行命令，否则向客户端返回一个MOVED错误，指引客户端转向至正确的节点，并再次发送之前想要执行的命令；

#### 计算键属于哪个槽

算法：`CRC16(key) & 16383`，CRC16(key)用于计算键key的CRC-16检验和，&16383用于取模；

#### 判断槽是否由当前节点负责处理

如果clusterState.slots[i]等于clusterState.myself，则说明槽i由当前节点负责；

#### 节点数据库的实现

节点只能使用0号数据库，单机Redis服务器没有这一限制；

### 重新分片

- Redis集群的重新分片操作可以将任意数量已经指派给某个节点的槽改为指派给另一个节点，并且相关槽所属的键值对也会从源节点被移动到目标节点；
- 重新分片操作可以在线进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求；

### ASk错误

在进行重新分片期间，源节点向目标节点迁移一个槽的过程中，可能会出现这种情况：属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面；

当客户端向源节点发送一个数据库键有关的命令，并且命令要处理的数据库键恰好就属于正在被迁移的槽时：

- 源节点会先在自己的数据库里面查找指定的键，如果找到则直接执行；
- 如果没找到，则这个键有可能已经被迁移到了目标节点，源节点将向客户端返回一个ASK错误，指引客户端转向正在导入槽的目标节点，并再次发送之前想要执行的命令；

### 复制和故障转移

Redis集群中的节点分为主节点和从节点，其中主节点用于处理槽，从节点用于复制某个主节点，并且在被复制的主节点下线时，代替下线主节点继续处理命令请求；

#### 设置从节点

向一个几点发送命令`CLUSTER REOLICATE <node_id>`，可以让接收命令的节点成为node_id对应节点的从节点，并开始对主节点进行复制；

#### 故障检测

- 集群中的每个节点都会定期地向集群中的其他节点发送PING消息，以此来检测对方是否在线，如果接收PING消息的节点没有在规定时间内返回PONG消息，那么发送的节点会将对方标记为疑似下线；
- 疑似下线信息被保存在clusterState中对应clusterNode.fail_reports链表里面，每个下线报告由一个clusterNodeFailReport表示，该结构会保存报告的节点，以及最后一次从node节点收到下线报告的时间；
- 如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为已下线FAIL。将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点x标记为已下线；

#### 故障转移

1. 复制下线节点的所欲偶从节点里面，会有一个节点被选中；
2. 被选中的从节点会执行SLAVEOF no one命令，成为新的主节点；
3. 新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己；
4. 新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点变成了主节点，并且这个主节点已经接管了原本已下线节点负责处理的槽；
5. 新的主节点开始接受和自己负责处理的槽有关的命令请求，故障转移完成；

#### 选举新的主节点















