# 深入理解Java虚拟机

## 自动内存管理

### Java内存区域与内存溢出异常

#### 运行时的数据区

##### 线程共享

**方法区**

- 用于存储已被虚拟机加载的内存信息、常量、静态变量，即时编译器编译后的代码缓存等数据
- 如果方法区无法满足新的内存分配的需求时，将抛出OutOfMemoryError异常
- 运行时的常量池：方法区的一部分，用于存放编译器生成的各种字面量和符号引用，当常量池无法再申请到内存时会抛出OutOfMemoryError异常

**堆（Heap）（GC堆）**

- 几乎所有对象实例和数组都在堆完成分配内存
- Java堆可以在物理上处于不连续的空间，但是逻辑上必须是连续的空间
- Java堆可以被设置为固定大小，也可以是可扩展的（通过参数-XMx和-Xms设定）
- 如果Java堆中没有内存完成实例分配，并且堆也无法扩展时，将抛出OutOfMemoryError

##### 线程私有

**程序计数器**：当前线程所执行的字节码的行号指示器（唯一一个没有OutOfMemoryError的区域）

**虚拟机栈**：

- Java方法执行时的线程内存模型
- 每个方法被调用时都会同步创建一个栈帧，用于存储局部变量表、操作数栈、动态连接、方法出口等信息
- 局部变量表：存储编译期可知的基本数据类型、对象引用和returnAddress类型
- 异常情况：如果线程请求的栈深度大于虚拟机所允许的栈深度，则抛出StackOverFlowError，如果Java虚拟机栈容量可以动态扩展并且扩展时无法获得足够的内存则抛出OutOfMemoryError

**本地方法栈**：

- 作用与虚拟机栈相同，但是服务于本地方法（native method）
- 和虚拟机栈一样，在栈深度溢出和栈扩展失败时分别抛出StackOverFlowError和OutOfMemoryError

##### 特殊

**直接内存：**

- 不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，但是这部分内存也被频繁使用，且可能导致OutOfMemoryError

- JDK1.4引入的NIO类，引入了一种通道与缓冲区的I/O方式，它可以使用native函数库直接分配**堆外内存**，如果忽略了这部分内存，则可能导致各区域内存总和大于物理内存，从而造成OutOfMemoryError

## 垃圾收集器与内存分配策略

### 对象已死吗

**引用计数器算法**

- 给对象添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1；当引用失效时，计数器就减一；任何时刻计数器为0的对象就是不可能再被使用的
- 主流虚拟机里没有使用此算法，因为它很难解决对象之间相互循环引用的问题

**可达性分析算法**

通过一系列的称为GC Roots的对象作为起始点，向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的

Java中可作为GC Roots的对象包括：

- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（即一般说的Native方法）引用的对象

### 引用

**强引用**

在程序代码中普遍存在，只要对象存在强应用，则永远不会被回收掉

**软引用**

描述一些还有用但非必须的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收

**弱引用**

只被弱引用关联的对象，在下一次垃圾回收发生时，都会被回收掉

**虚引用**

唯一的目的是在这个对象被回收时收到一个系统通知

### 生存还是死亡

1. 一个对象在被回收前<u>至少要经历两次被标记</u>（*这里有点疑问，如果一个类没有重写finalize()方法，那么它的对象不是只被标记一次就被回收了吗？*）的过程，如果对象被判定为不可达，则它会被第一次标记，然后根据此对象是否有必要执行finalize()方法进行筛选。假如对象没有覆盖finalize()方法或者finalize()方法已被虚拟机调用过（一个对象的finalize()方法最多只会被系统自动调用一次），则被虚拟机视为“没有必要执行”；
2. 如果对象被判定为有必要执行，则会被放入F-Queue队列，并在稍后被一条由虚拟机创建、低调度优先级的线程去执行（为防止队列阻塞，仅触发而不等待执行完）它们的finalize()方法。稍后收集器会对F-Queue中的对象进行第二次小规模标记；
3. 如果对象在finalize()中重新被引用链关联，则在第二次标记时会被移出“即将回收”的集合，没能逃脱的对象将被回收；

### 回收方法区

回收废弃常量和无用的类

**判断无用的类**

- 该类的所有实例已经被回收
- 加载该类的ClassLoader已经被回收
- 该类对象的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

### 垃圾收集算法

**分代收集理论**

1. 弱分代假说：绝大多数对象都是朝生夕灭的
2. 强分代假说：熬过越多次垃圾收集过程的对象越难以消亡

多个垃圾收集器一致的设计原则：收集器应该将Java堆划分出不同的区域，将回收对象依据其年龄（经历的垃圾回收次数）分配到不同区域存储。显然，如果一个区域中的大多数对象都是朝生夕灭的，那么每次回收时只需关注如何保留少量存活的对象，而不是标记大量要回收的对象；如果一个区域中大多数对象都是难以消亡的对象，则应该被以较低频率执行回收。

Minor GC：目标只是新生代的垃圾收集

Full GC：收集整个Java堆和方法区的垃圾收集

**标记清除算法**

- 首先标记出所有需要回收的对象，标记完成后统一回收
- 标记和清除两个过程的效率都不高
- 会产生大量的不连续的内存碎片

**标记复制算法**

- 将可用内存分为大小相等的两块，平时只使用其中一块，内存回收时，先把存活的对象复制到另外一块内存空间，再回收之前使用过的半个内存空间
- 缺点是可使用的内存减少了一半，并且在对象存活率很高的时候，效率会比较低
- 现在的商业虚拟机大多都优先采用了这种收集算法回收新生代
- Appel式回收：把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor，发生垃圾收集时，把Eden和Survivor中仍然存活的对象分配到另一块Survivor空间，然后直接清理掉Eden和已使用的Survivor空间。Hotspot默认Eden和Survivor的大小比例为8:1。当Survivor空间不足以容纳一次Minor GC后存活的对象时，会依赖其他区进行分配担保

**标记整理算法**

先标记，然后让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存

**分代收集算法**

- 根据对象存活周期的不同将内存划分为新生代和老年代
- 新生代对象存活率较低，使用复制算法，老年代对象存活率高，使用标记清除或标记整理算法
- 当前的商业虚拟机都采用分代收集算法

### 内存分配与回收策略

**对象优先在Eden分配**

当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC

**大对象直接进入老年代**

大量需要连续空间的Java对象，如很长的字符串和数组

**长期存活的对象将进入老年代**

对象在Eden出生并经过一次Minor GC后仍然存活，并且能被Survivor容纳的话，就会被移动到Survivor区，并且年龄设置为1，之后每次在Survivor区熬过一次Minor GC，对象年龄加1，直到对象15岁时，晋升到老年区

**动态对象年龄判断**

如果在Survivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，则年龄大于等于该年龄的对象直接进入老年代

**空间分配担保**

在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的

### 经典垃圾收集器

**Serial收集器**

- 单线程收集，在进行垃圾收集工作时，须暂停其他工作线程
- 所有收集器里额外内存消耗最小的收集器
- 对于运行在客户端模式下的虚拟机来说是一个很好的选择

**ParNew收集器**

- 实质上是Serial收集器的多线程并行版本
- Serial收集器和ParNew收集器能与CMS收集器配合工作

**Parallel Scavenge收集器**

其他收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（运行用户代码时间/（运行用户代码时间 + 运行垃圾收集时间））

**CMS（Concurrent Mark Sweep）收集器**

- 基于标记-清除算法实现
- 分为初始标记、并发标记、重新标记、并发清除四个阶段，其中初始标记和重新标记需要“Stop The World”（停止用户的线程）
- CMS默认启动的回收线程数是（处理器核心数量+3）/4，故当核心数量少于4个时，垃圾收集线程占用了超过25%的计算资源

**G1搜集器**

- 一款面向服务端应用的垃圾收集器，全功能收集器（延迟可控的情况下获得尽可能高的吞吐量）
- Mixed GC模式：可面向堆内存任何部分组成回收集，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大（G1以前的收集器只能选择对整个新生代（Minor GC）/老年代（Major GC）/Java堆（Full GC）进行GC）
- 基于Region的堆内存布局：把连续的Java堆划分为多个大小相等的独立Region，每个Region可以根据需要扮演新生代的Eden、Survivor空间，或者老年代空间。特殊区域Humongous区，用于存储大小超过Region容量一半的大对象。Region是单次回收的最小单元，每次收集到的空间都是Region大小的整数倍。优先处理回收价值收益最大的Region
- G1至少耗费10%-20%的额外内存来维持收集器工作
- 初始标记（标记GC Root能直接关联到的对象，并修改TAMS指针的值）→并发标记（对堆中对象做可达性分析）→最终标记（处理并发阶段遗留下来的少量SATB记录）→筛选回收（更新Region统计数据，把<u>决定回收的Region的存活对象复制到新的空Region，再清理整个旧Region空间</u>）
- 从G1开始，垃圾收集器的设计导向变为追求能够应付应用内存分配速率，而不追求一次能把整个Java堆全部清理干净

## 虚拟机性能监控与故障处理工具

### JDK的命令行工具

**JDK监控和故障处理工具**

| 名称   | 主要作用                                                     |
| ------ | ------------------------------------------------------------ |
| jps    | JVM Process Status Tool ，显示指定系统内所有的HotSpot虚拟机进程 |
| jstat  | JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据 |
| jinfo  | Configuration Info for Java，显示虚拟机配置信息              |
| jmap   | Memory Map for Java，生成虚拟机的内存转储快照                |
| jhat   | JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果 |
| jstack | Stack Trace for Java，显示虚拟机的线程快照                   |

### **jps（虚拟机进程状况工具）**

列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID（LVMID）

可选选项：

| 选项 | 作用                                               |
| ---- | -------------------------------------------------- |
| -q   | 只输出LVMID，省略主类名                            |
| -m   | 输出虚拟机进程启动时传递给主类main()函数的参数     |
| -l   | 输出主类的全名，如果进程执行的是Jar包，输出Jar路径 |
| -v   | 输出虚拟机进程启动时JVM参数                        |

**jstat（虚拟机统计信息监视工具）**

用于监视虚拟机各种运行状态信息的命令行工具，它可以显示本地或者虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据

**格式**：jstat [option] [vmid] [interval] [count]

比如jstat -gc 2764 250 20，每250毫秒查询一次进程2764的垃圾收集状况，一共查询20次

选项：

| 选项              | 作用                                                         |
| ----------------- | ------------------------------------------------------------ |
| -class            | 监视类装载、卸载数量、总空间以及类装载所耗费的时间           |
| -gc               | 监视Java堆状况，包括Eden区、两个survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息 |
| -gccapacity       | 监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间 |
| -gcutil           | 监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比 |
| -gccause          | 与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因      |
| -gcnew            | 监视新生代GC状况                                             |
| -gcnewcapacity    | 监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间 |
| -gcold            | 监视老年代GC状况                                             |
| -gcoldcapacity    | 监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间 |
| -gcpermcapacity   | 输出永久代使用到的最大、最小空间                             |
| -compiler         | 输出JFT编译器（即时编译器）编译过的方法、耗时等信息          |
| -printcompilation | 输出已经被JIT（即时编译器）编译的方法                        |

**jinfo（Java配置信息工具）**

作用是实时地查看和调整虚拟机各项参数，使用-flag选项可以查看虚拟机启动时未被显式指定的参数的系统默认值

**jmap（Java内存印象工具）**

用于生成堆转储快照，格式：jmap [option] vmid

选项合法值与具体含义如下表：

| 选项           | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| -dump          | 生成Java堆转储快照                                           |
| -finalizerinfo | 显示在F-Queue中等待Finalizer线程执行finalize方法的对象       |
| -heap          | 显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况等   |
| -histo         | 显示堆中对象统计信息，包括类、实例数量、合计容量             |
| -permstat      | 以ClassLoader为统计口径显示永久代内存状态                    |
| -F             | 当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照 |

**jhat（虚拟机堆转储快照分析工具）**

与jmap搭配使用，开分析jmap生成的堆转储快照，内置了一个微型的HTTP/HTML服务器，一般用不到

**jstack（Java堆栈跟踪工具）**

用于生成虚拟机当前时刻的线程快照，就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因（如线程间死锁、死循环、请求外部资源导致的长时间挂起等）

格式：jstack [option] vmid

选项：

| 选项 | 作用                                         |
| ---- | -------------------------------------------- |
| -F   | 当正常输出的请求不被响应时，强制输出线程堆栈 |
| -l   | 除堆栈信息外，显示关于锁的附加信息           |
| -m   | 如果调用到本地方法的话，可以显示C/C++的堆栈  |

JDK1.5中Thread类新增了getAllStackTraces()方法用于获取所有线程中的StackTraceElement对象，可以通过几行代码完成jstack的大部分功能（可在代码中调用此方法做一个管理页面）

### JDK的可视化工具

**JConsole**

路径：jdk/bin/jconsole.exe

**VisualVM**

路径：jdk/bin/jvisualvm.exe

## 类文件结构

### 概述

**Java一次编写，到处运行**

- 各种不同平台的Java虚拟机都支持的存储格式——字节码，是构成平台无关性的基石；
- Java虚拟机不与任何程序语言绑定，只与“Class文件”这种特定的二进制文件格式关联；

### Class类文件的结构

- Class文件是一组以8个字节为基础单位的二进制流
- Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构只有两种数据结构：无符号数（属于基本类型，以u1、u2、u4、u8分别代表1、2、4、8个字节）和表（由多个无符号数和其他表作为数据项构成的符合数据结构类型）。
- 当需要描述同一类型但是数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的集合。

#### 魔数与Class文件的版本

**魔数**：每个Class文件的头4个字节，唯一作用是确定这个文件是否能为一个能被虚拟机接受的Class文件，Class文件的魔数：0xCAFEBABE。

紧接着魔数的4个字节存储的是Class文件的版本号（第5、6个是次版本号，第7、8个是高版本号）

#### 常量池

- 紧接着主次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外它还是Class文件中第一个出现的表类型数据项目。
- 常量池中主要存放两大类变量：字面量（比较接近于Java语言常量的概念，比如文本字符串、被声明为final的常量值）和符合引用（包名，类、接口全限定名，字段、方法的名称和描述符，方法句柄和方法类型，动态调用点和动态常量）
- 常量池中的每一项常量都是一个表，截至JDK13，常量池中分别有17种不同类型的常量（这17类表都有一个共同的特点——表结构起始第一位是个u1类型的标志位，代表着当前常量属于哪种常量类型）

#### 访问标志

在常量池结束后，紧接着的2个字节代表访问标志（access_flags），这个标志用于标识一些类或接口层次的访问信息（这个Class是类还接口，是否定义为public，是否为abstract、final等）

#### 类索引、父类索引与接口索引集合

类索引与父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据集合。Class文件中由这三项数据来确定该类型的继承关系。

#### 字段表集合

- 用于描述接口或者类中声明的变量；
- 字段修饰符放在access_flags，紧跟着name_index（字段的简单名称）和descriptor_index（字段和方法的描述符）；
- 最后跟随着一个属性表集合，用于存储额外信息，比如 int m = 123，属性表存储123

#### 方法表集合

与字段吧集合非常类似，仅在访问标志和属性表集合的可选项中有区别

### 字节码指令简介

Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零或多个代表着此操作所需的参数（称为操作数，Operand）构成。

## 虚拟机类加载机制

代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步

### 概述

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制

### 类加载的时机

#### 生命周期

1. 加载（Loading）
2. 验证（Verification）
3. 准备（Preparation）
4. 解析（Resolution）
5. 初始化（Initialization）
6. 使用（Using）
7. 卸载（Unloading）

其中验证、准备、解析统称为连接（Linking）

#### 初始化

6种**有且仅有**必须立即对类进行初始化的情况

1）遇到new、getstatic、putstatic、invokestatic这四条字节码指令，即使用new实例化对象，读取或设置一个类的静态字段，调用一个类的静态方法

2）使用java.lang.reflect包的方法对类进行反射调用的时候

3）当初始化一个类的时候，如果其父类还没有进行过初始化，需先触发其父类的初始化

4）虚拟机启动时先初始化主类

5）使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例的最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则先触发其初始化

6) 当一个接口定义了JDK8新加入的默认方法（被default修饰的接口方法）时，如果有这个接口的实现类发生了初始化，则该接口要在其之前被初始化

以上6种行为称为对一个类型进行主动引用，而被动引用则不会触发初始化，3个例子：

1）通过子类调用父类的静态变量，只会初始化父类

2）创建类的数组，只会初始化一个代表此类的数组的类（Lorg.fenixsoft.classloading.SuperClass）

3）调用类的static final的常量，不会初始化，因为已在编译阶段将此常量放入了常量池

### 类加载的过程

#### 加载

在加载阶段，Java虚拟机需要完成以下三件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

#### 验证

- 确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，并且不会危害虚拟机自身的安全（Java虚拟机如果不检查输入的字节流，很可能会因为载入了有错误或者有恶意企图的字节码流而导致整个系统受攻击甚至崩溃）；
- 验证阶段大致上包含：文件格式校验（验证字节流是否符合Class文件的规范）、元数据验证（对字节码描述的信息进行语义分析，确保其符合Java语言规范）、字节码验证（通过数据流分析和控制流分析，确保程序语义是合法的、符合逻辑的）和符合引用验证（检查该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源）；

#### 准备

正式为类中定义的变量分配内存并设置类变量初始值（通常情况下是数据类型的零值（如果类字段的字段属性表中存在ConstantValue属性，则在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值））的阶段，这时候进行的内存分配仅包括静态变量而不包括实例变量

#### 解析

解析阶段是Java虚拟机将常量池中内的符号引用（以一组符号来描述所引用的目标，符号可以是任何形式的字面量）替换为直接引用（可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄）的过程

#### 初始化

- 在初始化阶段，会根据程序编码制定的主观计划去初始化类变量和其他资源，初始化阶段是执行类构造器<clinit>()方法的过程；
- <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的（<clinit>()方法对于接口和类并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，则编译器可以不为这个类生成<clinit>()方法），编译器收集的顺序是由语句在源文件中出现的顺序决定的；
- Java虚拟机会保证子类的<clinit>()方法执行前，父类的<clinit>()方法已执行完毕，因此在Java虚拟机中第一个被执行的<clinit>()方法的类型一定是java.lang.Object；
- 同一个类加载器下，一个类型只会被初始化一次；

### 类加载器

Java虚拟机团队有意把类加载阶段的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类，实现这个动作的代码被称为“类加载器”

#### 类与类加载器

对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性——即使两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

#### 双亲委派模型

站在Java虚拟机的角度来看，只存在两种不同的类加载器，一种是启动类加载器BootstrapClassLoader，它是C++语言实现的，是虚拟机自身的一部分；另一种是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且都继承自抽象类java.lang.ClassLoader。

对于JDK8及之前的版本，绝大多数Java程序都会使用到以下3个系统提供的类加载器来进行加载：

- 启动类加载器BootstrapClassLoader负责把存放在lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库加载到虚拟机内存中。
- 扩展类加载器ExtensionClassLoader负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中的所有的类库。
- 应用程序类加载器ApplicationClassLoader，负责加载用户类路径Class Path上所有的类库，一般情况下它就算程序中默认的类加载器。

**双亲委派模型**

<img src="D:\学习笔记\图片\双亲委派模型.PNG" style="zoom: 75%;" />

- 工作过程：如果一个类加载器收到了类加载的请求，它首先把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，因此所有的加载器请求最终都应该传到最顶层的启动类加载器中，只有父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。
- 使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就算Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放于lib/rt.jar之中，因此无论哪个类加载器要加载这个类，最终都是委派给最顶端的启动类加载器进行加载，因为Object类在程序的各种类加载器环境中都能保证是同一个类。
- 双亲委派模型的实现（java.lang.ClassLoader.loadClass()）：先检查请求加载的类型是否已被加载过，若没有则调用父类加载器loadClass()方法，若父类加载器为null则使用启动类加载器作为父加载器。假如父加载器加载失败，抛出ClassNotFoundException异常的话，才调用自己的findClass()方法尝试进行加载。

#### 破坏双亲委派模型

1. 由于双亲委派模型在JDK1.2之后才被引入而ClassLoader在Java第一个版本已存在，故JDK1.2新增了protected方法findClass()，并引导用户在编写类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码；
2. 第二次被破坏是由这个模型自身的缺陷造成的，双亲委派模型很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类越由越上层的加载器加载），但是如果有基础类型要调用用户的代码，则会出现问题。例如：JNDI服务由启动类加载器完成加载，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口，但是此时启动类加载器是绝不可能认识、加载这些代码的。为解决此困境，Java设计团队引入了线程上下文类加载器——它可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没设置过的话，则默认为应用程序类加载器。
3. 第三次被破坏是由于用户对程序动态性（代码热替换、模块热部署等）的追求而导致。如OSGi实现模块化热部署，其关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换，在OSGi环境下，类加载器不再是双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。

### Java模块化系统（Java Platform Module System，JPMS）

JDK9中引入的Java模块化系统是对Java技术的一次重要升级，为了能够实现模块化的关键目标——可配置的封装隔离机制，Java虚拟机对类加载架构也做了相应的变动调整，才使模块化系统得以顺利地运作。

## 虚拟机字节码执行引擎

### 概述

- 执行引擎是Java虚拟机核心的组成部分之一。物理机的执行引擎建立在处理器、缓存、指令集和操作系统层面，而虚拟机的执行引擎则是由软件自行实现的，因此可以执行不受物理条件约束地定制指令集与执行引擎地结构结构体系，从而能够执行那些不被硬件直接支持地指令集格式。
- 所有Java虚拟机的执行引擎的输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。

### 运行时的栈帧结构

- 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机栈的栈元素
- 存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息
- 每个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程
- 在编译源码时，栈帧中需要多大的局部变量表和多深的操作数栈就已经被分析计算出来，因此一个栈帧需要分配多数内存，并不会收到程序运行期变量数据的影响

#### 局部变量表

- 局部变量表是一组变量值的存储空间，用于存放方法参数和方法内定义的局部变量
- 局部变量的容量以容量槽（variable slot）为最小单位，每个变量槽都应该能存放一个boolean、byte、short、int、float、char、reference或returnAddress类型的数据
- **reference**：一是能根据引用直接或间接地查找到对象在Java堆中的数据存放的起始地址或索引；而是能根据引用直接或间接地查找到对象所属数据类型在方法区中存储的类型信息

#### 操作数栈

- 同局部变量表一样，操作数栈的最大深度也在编译的时候被被确定；
- 操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型；

#### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程的动态连接。Class文件的常量池中存在大量的符号引用，字节码的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用时被转化为直接引用，这种转化被称为静态解析，另一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。

#### 方法返回地址

- 当一个方法开始执行后，只有两种推出方法的方式：一是遇到任意一个方法返回的字节码指令（正常调用完成），而是在方法执行的过程中遇到了异常并且它没有在方法体内得到妥善处理（异常调用完成）。
- 一般来说，方法正常退出时，主调方法的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器的值，而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存这部分信息。

### 方法调用

方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务是确定被调用方法的版本，暂时还未涉及方法内部的具体运行过程。

#### 解析

- 所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的，这类方法的调用被称为解析。
- Java虚拟机支持以下5条方法调用字节码指令，分别是：invokestatic（调用静态方法）、invokespecial（调用实例构造器<init>()方法、私有方法和父类中的方法）、invokevirtual（调用虚方法）、invokeinterface（调用接口方法，会在运行时在确定一个实现该接口的对象）、invokedynamic（先在运行时动态解析出调用点限定符所引用的方法，然后执行该方法）。前4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。
- 只要能被invokestatic和invokespecial指令调用的方法，都可以在解析时确定唯一的调用版本，符合此条件的方法共有静态方法、私有方法、实例构造器、父类方法四种，再加上被final修饰的方法（尽管它使用invokevirtual指令调用），这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用，这些方法统称为“非虚方法”（Non-Virtual Method），其他方法被称为“虚方法”（Virtual Method）。

#### 分派

**静态分派**

```java
Human man = new Man();
```

- 这里我们把Human称为变量的静态类型（Static Type），或者外观类型（Apparent Type），后面的Man则称为实际类型（Actual Type）或者运行时类型（Runtime Type）。静态类型和实际类型在程序中都可能发生变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的，而实际类型变化的结果在运行期才可确定。
- 虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判断依据的，由于静态类型在编译器可知，所以在编译阶段，Javac编译器就根据参数的静态类型决定了会使用哪个重载版本。
- 所有依赖静态类型来决定方法执行版本的分派动作，都被称为静态分派，其最典型的应用表现就是方法重载。

**动态分派**

- 它与Java语言多态性地另外一个重要体现——重写（Ovirride）有着密切的关联。
- invokevirtual指令解析过程：1.找到操作数栈顶的第一个元素指向的对象的实际类型C；2.如果在类型C找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，否则返回java.lang.IllegalAccessError异常；3.如果第2步没找到，则按照继承关系上下往上依次对C的各个父类进行第二步的搜索和验证过程；4.如果始终找不到合适的方法，则抛出java.lang.AbstractMethodError异常。这个过程就是Ovriride的本质。
- 这种在运行期间根据实际类型确定方法执行版本的分派过程称为动态分派。

**单分派与多分派**

方法的接收者与方法的参数统称为方法的宗量，根据分派有多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标i方法进行选择（Override），多分派则是根据一个宗量对目标方法进行选择（Overload）

**虚拟机动态分派的实现**

动态分派是非常频繁的动作，Java虚拟机实现基于执行性能的考虑，真正运行时一般不会如此频繁地去反复搜索合适地目标方法，一种基础而常见地优化手段是为类型在方法区种建立一个虚方法表（如果子类重写了父类的方法，则子类虚方法表种地址指向子类实现的版本的入口地址，否则指向父类版本的入口地址）。

### 动态类型语言支持

#### 动态类型语言

动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的，如JavaScript、Python、PHP、Ruby等。相对地，在编译器就进行类型检查过程的语言，如C++和Java就是最常用的静态类型语言。

#### java.lang.invoke包

- 在之前单纯依靠符号引用来确定调用的目标方法这条路以外，提供一种新的动态确定目标方法的机制，称为“方法句柄”（Method Handle）。
- MethodHandle与Reflection有众多相似之处，但是MethodHandle是在模拟字节码层次的方法调用，Reflection是方法在Java端的全面映像，前者服务于所有Java虚拟机之上的语言，后者仅为Java语言服务。

### 基于栈的字节码解释执行引擎

- Java编译器输出的字节码指令流，基本上是一种基于栈的指令集架构（Instruction Set Architecture，ISA），字节码指令流里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作。与之相对的另一套常用的指令集架构是基于寄存器的指令集，最典型的就是X86的二地址指令集。
- 基于栈的指令集主要优点是可移植，另外代码相对紧凑、编译器实现更加简单等。主要缺点是理论上执行的速度相对来说会稍慢一些。

## 前端编译与优化

### 概述

- 前端编译器：把java文件转变为class文件，如JDK的Javac、Eclipse JDT中的增量式编译器ECJ；
- 即时编译器：Java虚拟机的即时编译器（JIT编译器），运行期把字节码转变为本地机器码的过程，如HotSpot虚拟机的C1、C2编译器，Graal编译器；
- 提前编译器：直接把程序编译成与目标机器指令集相关的二进制代码，如JDK的Jaotc；

### Java语法糖

#### 泛型

- 泛型的本质是参数化类型或者参数化多态的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数类型能够用在类、接口和方法的创建中，分别构成泛型类、泛型接口、泛型方法。
- Java选择的泛型实现方式叫作“类型擦除式泛型”（Java语言的泛型只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型）
- Java类型擦除实现方式：在编译时把泛型还原为裸类型，只在元素访问、修改时自动插入一些强制类型转换和检查指令

## 后端编译与优化

### 概述

如果我们把字节码看作是程序语言的一种中间表示形式的话，那编译器无论在何时、在何种状态下把Class文件转换成本地基础设施相关的二进制字节码，它都可以视为整个编译过程的后端。

### 即时编译器

当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为“热点代码”，为了提高热点代码的执行效率。在运行时，虚拟机会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务地后端编译器被称为即时编译器。

#### 解释器与编译器

主流地商用Java虚拟机（HotSpot、OpenJ9等），内部都同时包含解释器与编译器，当程序需要迅速启动和执行地时候，解释器可以首先发挥作用，省去编译地时间，立即运行。当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率。

### 编译器优化技术

#### 方法内联

- （在即时编译过程中遇到方法调用时，直接编译目标方法的方法体，并替换原方法调用）。
- 大多数Java方法都无法进行内联，因为只有使用invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法才会在编译期进行解析。除上述四种方法之外（最多再除去被final修饰的方法），其他的Java方法的调用都必须在运行时进行方法接收者的多态选择。
- 为解决虚方法的内联问题，Java虚拟机引入一种名为类型继承关系分析的技术，用于确定在目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类并被覆盖某个虚方法。

#### 逃逸分析

- 分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸；甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问到的实例变量，这种称为线程逃逸。
- 根据一个对象的逃逸程度，可对其实例采取不同程度的优化，逃逸分析并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。

#### 公共子表达式消除

如果一个表达式E之前已经被计算过了，并且从先前的计算到现在的E中所有的变量的值都没发生变化，那么对于这种表示式，没有必要花时间再对它重新进行计算，只需用前面计算过的表达式结果代替E。

#### 数组边界检查消除

数组访问发生在循环之中，并且使用循环变量来进行数组的访问，如果编译器只通过数据流分析就可以判定循环变量的取值范围永远在区间[0, foo.length)之内，那么在循环中就可以把整个数据的上下界检查消除掉。

## Java内存模型与线程

### 硬件的效率与一致性

- 由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓存。
- 基于高速缓存的存储交互很好地解决了处理器与内存速度之间的矛盾，但是它也引入了一个新的问题：缓存一致性。
- 在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，这种系统称为共享内存多核系统。为解决一致性问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。
- 除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化——处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的。

### Java内存模型

Java内存模型的主要目的是定义程序中各种变量（此处的变量不包括局部变量与方法参数，因为它们是线程私有的）的访问规则，关注虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。

#### 主内存与工作内存

Java内存模型规定了所有的变量都存储在主内存（Main Memory）中，每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据，不同线程之间无法直接访问对方工作内存中的变量，线程间的变量值的传递均需要通过主内存来完成。

#### 内存间交互操作

Java内存模型中定义了8种操作来完成主内存与工作内存之间的交互协议，Java虚拟机在实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double、long类型变量允许有例外）：

| 操作           | 作用域       | 说明                                                         |
| -------------- | ------------ | ------------------------------------------------------------ |
| lock（锁定）   | 主内存变量   | 把一个变量表示为一个线程独占的状态                           |
| unlock（解锁） | 主内存变量   | 把一个处于锁定状态的变量释放出来，使其之后可以被其他线程锁定； |
| read（读取）   | 主内存变量   | 把一个变量的值从主内存传输到线程的工作内存中；               |
| load（载入）   | 工作内存变量 | 把read操作从主内存中得到的变量值放入到工作内存的变量副本中； |
| use（使用）    | 工作内存变量 | 把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作； |
| assign（赋值） | 工作内存变量 | 把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作； |
| store（存储）  | 工作内存变量 | 把一个变量的值从工作内存中传送到主内存中，以便随后的write操作使用； |
| write（写入）  | 主内存变量   | 把store操作从工作内存中得到的变量的值放入主内存的变量中；    |

#### 对于volatile型变量的特殊规则

volatile变量具有两项特性：

- 保证此变量对所有线程的可见性——当一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的；
- 禁止指令重排序优化；

由于volatile变量只能保证可见性，在**不符合**以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性：

- 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值；
- 变量不需要与其他的状态变量共同参与不变约束；

#### 针对long和double型变量的特殊规则

允许虚拟机将没有被volatile修饰的64位读写操作划分为两次32位的操作来进行

#### 原子性、可见性与有序性

##### **原子性**

- 由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store、write这六个，大致可以认为，基本数据类型的访问、读写都是具备原子性的（例外就是long和double的非原子性协定）
- 如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock、unlock操作，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorrexit来隐式地使用这两个操作，反映到Java代码中就是同步块synchronized关键字；

**可见性**

- 可见性指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改；
- volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点；
- 除了volatile之外，synchronized和final也能实现可见性；

**有序性**

- 在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的；
- Java提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，前者本身就包含了禁止指令重排序的语义，后者则是由”一个变量在同一时刻只允许一条线程对其进行lock操作“这条规则获得；

#### 先行发生原则

先行发生是Java内存模型中定义的两项操作之间的偏序关系，比如操作A先行发生于操作B，即操作A产生的影响能被操作B观察到。

- **程序次序规则**：一个线程内，书写在前面的操作先于书写在后面的操作；
- **管程锁定规则**：一个unlock操作先行发生于后面对同一个锁的lock操作；
- **volatile变量规则**：对一个volatile变量的写操作先行发生于后面对这个变量的读操作；
- **线程启动规则**：Thread对象的start()方法先行于此线程的每一个动作；
- **线程终止规则**：线程中所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行；
- **线程中断规则**：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
- **对象终结规则**：一个对象的初始化完成先行发生于它的finalize()方法的开始；
- **传递性**：如果A先行与B，B先行于C，则A一定先行于C；

### Java与线程

#### 线程的实现

**Java线程的实现**：主流商用Java虚拟机的线程模型普遍使用基于操作系统原生线程模型（内核线程（Kernel-Level Thread KLT），由内核完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上）来实现，以HotSpot为例，它不会去关涉线程调度，全权交给底下的操作系统去处理，所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，都是由操作系统全权决定和完成的。

#### Java线程调度

- 线程调度是指系统为线程分配处理器使用权的过程，主要有两种方式：协同式（Cooperative Threads-Scheduling）线程调用和抢占式（Preemptive Threads-Scheduling）线程调度；
- 协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把工作执行完了之后，要主动通知系统切换到另外一个线程上去，其最大的好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对于自己是可知的，所以一般没有什么线程同步的问题；
- 如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。譬如在Java中，有Thread::yeild()方法可以主动让出执行时间，但是如果想要主动获取执行时间，线程本身是没有什么办法的。在这种实现线程调度方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程甚至整个系统阻塞的问题。Java使用的线程调度方式就是抢占式调度；

#### 状态转换

Java语言定义了6种线程状态，任意一个时间点，一个线程只能有且仅有其中一种状态，并可以通过特定的方法在不同状态之间转换：

- 新建（New）：创建后尚未启动的线程处于这种状态；
- 运行（Runnable）：包括操作系统线程状态种的Running和Ready，即线程可能正在执行，也可能正在等待着操作系统为它分配执行时间；
- 无限期等待（Waiting）：处于此状态的线程不会被分配处理器执行时间，它们要等待被其他线程显示唤醒（以下方法会让线程陷入此状态：1.没有设置Timeout参数的Object::wait()方法；2.没有设置Timeout参数的Thread::join()方法；3.Lock Support::park()方法）；
- 限期等待（Timed Waiting）：处于此状态的线程不会被分配处理器执行时间，在一段时间后会被系统自动唤醒（以下方法会让线程陷入此状态：1.Thread::sleep()方法；2.设置了Timeout参数的Object::wait()方法；3.设置了Timeout参数的Thread::join()方法；4.Lock Support::parkNanos()方法；5.LockSupport::parkUntil()方法）；
- 阻塞（Blocked）：线程被阻塞了，”阻塞状态“与”等待状态“的区别是，前者在等待着获取到一个排他锁，这个事件将在另一个线程放弃这个锁的时候发生；而后者则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入阻塞状态；
- 结束（Terminated）：已终止线程的线程状态，线程已经结束执行；

<img src="D:\学习笔记\图片\线程状态转换.PNG" style="zoom:67%;" />

## 线程安全与锁优化

### 线程安全

当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么就称这个对象是线程安全的。

#### Java语言中的线程安全

**不可变**

不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全的保障措施。

**绝对线程安全**

非常严格，即时所有方法都被修饰成synchronized，也不意味着调用它的时候就永远都不再需要同步手段了（如Vector）

**相对线程安全**

- 通常意义上所讲的线程安全，保证了对对象单次的操作是线程安全的，我们在调用时不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能在调用端使用额外的同步手段来保证调用的正确性；
- Java中的Vector、Hashtable、Collections的synchronizedCollection()方法包装的集合等；

**线程兼容**

- 对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用；
- Java类库API中大部分类都是线程兼容地，如ArrayList和HashMap等；

### 线程对立

- 不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码；
- Java语言天生就支持多线程地特性，线程对立地代码很少出现，而且通常都是有害地，应当尽量避免；
- 一个线程对立地例子是Thread类地suspend()和resume()方法，如果有两个线程同时持有一个线程对象，一个尝试去中断线程，一个尝试去恢复线程，在并发进行地情况下，无论调用时是否进行了同步，目标线程都存在死锁风险——假如suspend()中断地线程就是即将要执行resume()的那个线程，则肯定会产生死锁（也正是因为如此，这两个方法被声明废弃了）；

#### 线程安全的实现方法

##### 互斥同步

- 同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一条线程使用；
- 互斥是实现同步的一种手段，临界区、互斥量和信号量都是常见的互斥实现方式；

**synchronized实现：**

- synchronized关键字就是使用互斥同步手段实现的，它是一种块结构的同步语法。在synchronized关键字经过Javac编译之后，会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令，这两个指令都需要一个reference类型的参数来指明要锁定和解锁的对象。（如果代码中synchronized明确指定了对象参数，那就以这个对象的引用作为reference，如果没有明确指定，那如果其修饰的方法为实例方法，则锁对象实例，如果为类方法，则取Class对象）；
- 在执行monitorenter指令时，首先要尝试去获取对象的锁，如果其没被锁定，或者当前线程已经持有了那个对象的锁，则把锁的计数器的值加一，反之在执行了monitorexit指令会将计数器的值减一，一旦计数器的值为0，则释放锁。故synchronized是可重入的，且在持有锁的线程执行完毕并且释放锁之前，其他想进入同步块的线程会被无条件地阻塞；
- synchronized是Java语言中的一个重量级的操作，虚拟机本身会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，以避免频繁地切入核心态之中；

**Lock：**

- 基于Lock接口，用户能够以非块结构来实现互斥同步，从而摆脱了语言特性的束缚，改为在类库层面去实现同步；
- 可重入锁ReentrantLock是Lock接口最常见的一种实现，顾名思义它是可重入的，相比synchronized增加了<u>等待可中断</u>（当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情）、可实现<u>公平锁</u>（多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，一旦使用了公平锁，会导致ReentrantLock的性能急剧下降，明显影响吞吐量）及可以<u>绑定多个条件</u>（一个ReentrantLock对象可以同时绑定多个Condition对象——在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联时，就不得不额外添加一个锁；而ReentrantLock则无须这样做，多次调用newCondition()方法即可）；
- 自JDK6起对synchronized优化之后，synchronized与ReentrantLock的性能基本上能够持平，因此在只需要基础的同步功能时，synchronized是一个不错的选择，而Lock还需要确保在finally块中释放锁（而synchronized可以由虚拟机来确保锁被自动释放）；

##### 非阻塞同步

- 互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销，因此也被称为阻塞同步。互斥同步属于一种悲观的并发策略。随着指令集的发展（要求操作和冲突检测这两个步骤具备原子性，如CAS），有了基于冲突检测的乐观并发策略，乐观并发策略的实现不需要把线程阻塞挂起，因此这种同步操作被称为非阻塞同步；
- CAS（Compare-and-swap）需要有三个操作数，分别是内存位置V，旧的预期值A和准备设置的新值B，当且仅当V符合A时，处理器才会用B更新V的值，否则不执行更新；

##### 无同步方案

- 可重入代码（Reentrant Code）：又被称纯代码，是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。在特指多线程的上下文语境里，所有可重入的代码都是线程安全的；
- 线程本地存储（Thread Local Storage）：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样无须同步也能保证线程之间不出现数据争用的问题；

### 锁优化

#### 自旋锁与自适应自旋

- 互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要传入到内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。因此我们让后面请求锁的线程在等待期间不放弃处理器的执行时间，让线程执行一个忙循环（自旋），这项技术就是自旋锁。
- 自适应自旋：自旋的时间不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者状态来决定；

#### 锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判断依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。

#### 锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即时没有线程竞争，频繁地进行互斥同步地操作也会导致不必要地性能损耗。如果虚拟机探测到有这样一串零碎地操作都对同一对象加锁，将会把加锁同步地范围扩展（粗化）到整个操作序列地外部，这样只需要加锁一次就可以了。

#### 轻量级锁

- 轻量级是相对于使用操作系统互斥量来实现的传统锁而言的，它并不是用来代替重量级锁的，而是为了在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗；
- HotSpot虚拟机的对象头（Object Header）分为两部分，第一部分用于存储自身的运行时的数据，如HashCode、GC分代年龄等，这部分数据的长度在32位和64位的虚拟机中分别会占用32个或64个比特，官方称它为“Mark Word”。另一部分用于存储指向方法区对象类型数据的指针，如果是数组对象，还会有一个额外的部分用于存储数组长度。
- Mark Word被设计成一个非固定的动态数据结构，以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。32位HotSpot虚拟机对象头Mark Word如下：

<table style="text-align: center">
    <thead>
        <tr>
            <th rowspan="3">锁状态</th>
            <th colspan="5">32bit</th>
        </tr>
        <tr>
            <th colspan="2">25bit</th>
            <th rowspan="2">4bit</th>
            <th>1bit</th>
            <th>2bit</th>
        </tr>
        <tr>
            <th>23bit</th>
            <th>2bit</th>
            <th>偏向模式</th>
            <th>标志位</th>
        </tr>
    </thead>
    <tbody>
    	<tr>
        	<td>未锁定</td><td colspan="2">对象哈希码</td><td>分代年龄</td><td>0</td><td>01</td>
        </tr>
        <tr>
        	<td>轻量级锁定</td><td colspan="4">指向调用栈中锁记录的指针</td><td>00</td>
        </tr>
        <tr>
            <td>重量级锁定(锁膨胀)</td><td colspan="4">指向重量级锁的指针</td><td>10</td>
        </tr>
        <tr>
        	<td>GC标记</td><td colspan="4">空</td><td>11</td>
        </tr>
        <tr>
            <td>可偏向</td><td>线程ID</td><td>Epoch</td><td>分代年龄</td><td>1</td><td>01</td>
        </tr>
    </tbody>
</table>

**轻量级锁的工作过程**

1. 在代码即将进入同步块时，如果此同步对象没有被锁定（标志位为01状态），虚拟机首先在当前线程的栈帧中创建一个名为锁记录（Lock Record）的空间，用于存储当前Mark Word的copy（即Displaced Mark Word）；
2. 然后虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针，如果这个更新动作成功了，即代表了该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位转变为00，表示此对象处于轻量级锁定状态；
3. 如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁，虚拟机会首先检查对象的Mark Word是否指向当前线程的栈帧，如果是则说明当前线程已经拥有了这个对象的锁，那就进入同步块。否则说明锁对象已经被其他线程抢占了。如果出现两个以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须膨胀为重量级锁，表标志位状态值变为10。此时Mark Word中存储的就是指向重量级锁的指针，后面等待锁的线程也必须进入阻塞状态；

轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则，如果没有竞争，则轻量级锁通过CAS操作成功避免了使用互斥量的开销，反之如果存在锁竞争，除了互斥量的开销外，还发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。

#### 偏向锁

- 目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能（在无竞争的情况下把整个同步都消除掉）；
- 这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步；
- 假设当前虚拟机启用了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为01，把偏向模式设置为1，表示进入偏向模式，同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作等）；

偏向锁、轻量级锁的状态转化及对象Mark Word的关系如下图所示：

![](D:\学习笔记\图片\偏向锁、轻量级锁的状态转换及对象Mark Word的关系.PNG)